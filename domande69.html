<!-- 69 -->
<html><HEAD><TITLE>Test VCA - test numero 69</TITLE><head><body>
<center><h2>Test VCA - test numero 69</h2></center><hr>
<center><h3><b>Domanda 1</b></h3></center>
	<domanda>
		In una cache completamente associativa:

<ul>
<li><b>A</b> 		Ogni blocco di memoria ha un solo possibile blocco di cache che pu&ograve; ospitarlo
</li>
<li><b>B</b> 		Ogni blocco di memoria pu&ograve; essere ospitato in qualsiasi blocco di cache
</li>
<li><b>C</b> 		Nessuna delle precedenti
</li>
<li><b>D</b> 		Ogni blocco di memoria ha diversi possibili blocchi di cache che possono ospitarlo, ma non tutti
</li>
</ul>
<center><h3><b>Domanda 2</b></h3></center>
Si consideri il seguente metodo per il calcolo del fattoriale
<pre>
public static long fattoriale(long n) {
	if (n == 0)
		return 1;
	else
		return n * fattoriale(n-1);
}
</pre>
Solo una delle seguenti affermazioni &egrave; vera. Dire quale.

<ul>
<li><b>A</b> Il numero massimo di record di attivazione presenti nello stack a seguito dell&#x27;invocazione del metodo non dipende da <tt>n</tt>.
</li>
<li><b>B</b> Lo Stack della Java Virtual Machine contiene, ad ogni istante, soltanto un record di attivazione relativo al metodo.
</li>
<li><b>C</b> Il numero di record di attivazione presenti nello stack quando il metodo viene invocato con valore <tt>0</tt> del parametro &egrave; <tt>n+1</tt>.
</li>
<li><b>D</b> Non &egrave; possibile stabilire a priori il numero massimo di record di attivazione che saranno presenti nello stack in seguito all&#x27;invocazione del metodo.
</li>
</ul>
<center><h3><b>Domanda 3</b></h3></center>
	<domanda>
		La reificazione di una relazione &egrave; una operazione prevista nella metodologia di progettazione concettuale di basi di dati e consiste nella trasformazione di una relazione in una entit&agrave;.  Una sola delle seguenti affermazioni sulla reificazione di una relazione &egrave; corretta. Quale?

<ul>
<li><b>A</b> 		La reificazione di una relazione produce una nuove relazione in ISA con quella originaria;
</li>
<li><b>B</b> 		Se la relazione R ha n ruoli, allora la reificazione della relazione R produrr&agrave; una entit&agrave; che parteciper&agrave; ad n relazioni, dove ciascuna partecipazione sar&agrave; caratterizzata dalla cardinalit&agrave; (1,1);
</li>
<li><b>C</b> 		Se la relazione R &egrave; in ISA con un&#x27;altra relazione, allora non pu&ograve; essere oggetto di reificazione.  
</li>
<li><b>D</b> 		La reificazione di una relazione pu&ograve; essere applicata solo se la relazione non ha attributi;
</li>
</ul>
<center><h3><b>Domanda 4</b></h3></center>
	<domanda>
		Per quale motivo si digitalizzano i segnali analogici mediante campionamento e quantizzazione?

<ul>
<li><b>A</b> 		solo per poterli memorizzare in sistemi digitali (es: in computer)
</li>
<li><b>B</b> 		per poterli trasmettere in sistemi digitali con migliori prestazioni e migliore qualit&agrave;
</li>
<li><b>C</b> 		solo per poterli trasmettere a velocit&agrave; molto maggiori rispetto a quelle analogiche
</li>
<li><b>D</b> 		per poterli trasmettere contemporaneamente ad altri segnali
</li>
</ul>
<center><h3><b>Domanda 5</b></h3></center>
	<domanda>
		Quale tipologia di visita in profondit&agrave; di un albero risulta asintoticamente pi&ugrave; rapida? 

<ul>
<li><b>A</b> 		In ordine anticipato (pre-order)
</li>
<li><b>B</b> 		Tutte a pari merito 
</li>
<li><b>C</b> 		In ordine simmetrico (in-order)
</li>
<li><b>D</b> 		In ordine posticipato (post-order)
</li>
</ul>
<center><h3><b>Domanda 6</b></h3></center>
	<domanda>
Si consideri il seguente metodo Java:
<pre>
public static void cosaFa(int[] v, short y) {
	int i = 0;
	while (i&lt;v.length) v[++i] = y;
}
</pre>
Una sola delle seguenti affermazioni &egrave; vera. Quale?

<ul>
<li><b>A</b> 		Il metodo genera una eccezione di tipo <tt>ArrayIndexOutOfBoundsException</tt>.
</li>
<li><b>B</b> 		Il metodo scrive il valore <tt>y</tt> in tutte le celle dell&#x27;array <tt>v</tt>.
</li>
<li><b>C</b> 		Il metodo genera una eccezione di tipo <tt>PossibleLossOfPrecision</tt> poich&egrave; non &egrave; possibile assegnare uno <tt>short</tt> a una variabile <tt>int</tt>.
</li>
<li><b>D</b> 		Il metodo genera un errore di compilazione perch&egrave; <tt>length</tt> andrebbe scritto <tt>lenght</tt>
</li>
</ul>
<center><h3><b>Domanda 7</b></h3></center>
		Gli autovalori di un sistema ad anello chiuso coincidono con 

<ul>
<li><b>A</b> 		i poli della funzione di trasferimento ad anello aperto pi&ugrave; eventuali autovalori nascosti;
</li>
<li><b>B</b> 		i poli della funzione di trasferimento ad anello chiuso pi&ugrave; eventuali autovalori nascosti;
</li>
<li><b>C</b> 		i poli della funzione di trasferimento ad anello aperto.
</li>
<li><b>D</b> 		i poli della funzione di trasferimento ad anello chiuso;
</li>
</ul>
<center><h3><b>Domanda 8</b></h3></center>
		Quali tra le seguenti istruzioni dichiara e inizializza correttamente un array bidimensionale ? Scegliere una risposta.

<ul>
<li><b>A</b> 		int a[][] = new int[10,10]
</li>
<li><b>B</b> 		int [a][] = new int[10][10];
</li>
<li><b>C</b> 		int a[][] = new int[10][10];
</li>
<li><b>D</b> 		int a[10][10] = new int[][];
</li>
</ul>
<center><h3><b>Domanda 9</b></h3></center>
	<domanda>
		Quale fra le seguenti <b>di norma</b> non &egrave; una propriet&agrave; delle funzioni hash ? 

<ul>
<li><b>A</b> 		Determinismo
</li>
<li><b>B</b> 		Suriettivit&agrave;
</li>
<li><b>C</b> 		Iniettivit&agrave;
</li>
<li><b>D</b> 		Tempo di calcolo indipendente dal numero di chiavi in tabella
</li>
</ul>
<center><h3><b>Domanda 10</b></h3></center>
	<domanda>
Si consideri la seguente espressione booleana:
<tt>!(a || b) && b</tt>
Una sola delle seguenti affermazioni &egrave; vera. Quale?

<ul>
<li><b>A</b> l&#x27;espressione restituisce true solo quando b==true e a==false.
</li>
<li><b>B</b> l&#x27;espressione restituisce true solo quando b==true.
</li>
<li><b>C</b> l&#x27;espressione restituisce sempre true.
</li>
<li><b>D</b> l&#x27;espressione restituisce sempre false.
</li>
</ul>
</body></html>
