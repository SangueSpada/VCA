<!-- 36 -->
<html><HEAD><TITLE>Test VCA - test numero 36</TITLE><head><body>
<center><h2>Test VCA - test numero 36</h2></center><hr>
<center><h3><b>Domanda 1</b></h3></center>
	<domanda>
		Le modulazioni numeriche in banda traslata si utilizzano per multiplare pi&ugrave; segnali numerici sullo stesso canale. 

<ul>
<li><b>A</b> 		A parit&agrave; di banda del canale, pi&ugrave; &egrave; larga l&rsquo;occupazione in banda del segnale, pi&ugrave; &egrave; alto il numero di segnali che possono essere trasmessi contemporaneamente
</li>
<li><b>B</b> 		Non esiste alcuna dipendenza tra la banda del segnale e il numero di segnali numero di segnali che possono essere trasmessi contemporaneamente
</li>
<li><b>C</b> 		A parit&agrave; di banda del segnale, meno &egrave; larga l&rsquo;occupazione in banda del canale, pi&ugrave; &egrave; alto il numero di segnali che possono essere trasmessi contemporaneamente
</li>
<li><b>D</b> 		A parit&agrave; di banda del canale, meno &egrave; larga l&rsquo;occupazione in banda del segnale, pi&ugrave; &egrave; alto il numero di segnali che possono essere trasmessi contemporaneamente
</li>
</ul>
<center><h3><b>Domanda 2</b></h3></center>
	<domanda>
		Quale tipologia di visita di un albero di ricerca binario (BST) ne esamina la chiavi in ordine crescente? 

<ul>
<li><b>A</b> 		In profondit&agrave; con ordine posticipato (post-order)
</li>
<li><b>B</b> 		In profondit&agrave; con ordine anticipato (pre-order)
</li>
<li><b>C</b> 		In profondit&agrave; con ordine simmetrico (in-order)
</li>
<li><b>D</b> 		In ampiezza
</li>
</ul>
<center><h3><b>Domanda 3</b></h3></center>
	<domanda>
		L&#x27;assegnazione degli autovalori consente di	

<ul>
<li><b>A</b> 		controllare la risposta transitoria;
</li>
<li><b>B</b> 		ricostruire asintoticamente lo stato del processo;
</li>
<li><b>C</b> 		progettare un controllore a dimensione minima;
</li>
<li><b>D</b> 		effettuare la reiezione completa dei disturbi.
</li>
</ul>
<center><h3><b>Domanda 4</b></h3></center>
	<domanda>
		La fase di progettazione logica di basi di dati procede attraverso i passi di ristrutturazione dello schema concettuale, traduzione diretta e ristrutturazione dello schema logico. Una sola delle seguenti affermazioni sulla progettazione logica &egrave; corretta. Quale?

<ul>
<li><b>A</b> 		La traduzione diretta ha lo scopo di derivare lo schema logico corrispondente allo schema concettuale ristrutturato, traducendo ogni entit&agrave; in una tabella, ed ogni relazione non accorpata in una tabella.
</li>
<li><b>B</b> 		La ristrutturazione dello schema concettuale ha lo scopo di ottimizzare le tabelle relazionali;
</li>
<li><b>C</b> 		Dopo la traduzione diretta non ci sono tabelle relazionali che ammettono valori nulli nei propri attributi;
</li>
<li><b>D</b> 		La ristrutturazione dello schema logico si effettua solo se ci sono attributi composti, attributi multivalore o relazioni ISA nello schema concettuale;
</li>
</ul>
<center><h3><b>Domanda 5</b></h3></center>
Si consideri il seguente metodo per il calcolo del fattoriale
<pre>
public static long fattoriale(long n) {
	if (n == 0)
		return 1;
	else
		return n * fattoriale(n-1);
}
</pre>
Solo una delle seguenti affermazioni &egrave; vera. Dire quale.

<ul>
<li><b>A</b> Lo Stack della Java Virtual Machine contiene, ad ogni istante, soltanto un record di attivazione relativo al metodo.
</li>
<li><b>B</b> Il numero di record di attivazione presenti nello stack quando il metodo viene invocato con valore <tt>0</tt> del parametro &egrave; <tt>n+1</tt>.
</li>
<li><b>C</b> Non &egrave; possibile stabilire a priori il numero massimo di record di attivazione che saranno presenti nello stack in seguito all&#x27;invocazione del metodo.
</li>
<li><b>D</b> Il numero massimo di record di attivazione presenti nello stack a seguito dell&#x27;invocazione del metodo non dipende da <tt>n</tt>.
</li>
</ul>
<center><h3><b>Domanda 6</b></h3></center>
	<domanda>
Quali parti della dichiarazione di un metodo costituiscono la sua &quot;segnatura&quot; ?

<ul>
<li><b>A</b> Il nome del metodo, il tipo, numero ed ordine dei parametri formali ed il tipo del valore restituito
</li>
<li><b>B</b> Il nome del metodo, il tipo dei parametri formali ed il tipo del valore restituito.
</li>
<li><b>C</b> Il nome del metodo, il tipo, numero ed ordine dei parametri formali, il tipo del valore restituito e gli eventuali modificatori.
</li>
<li><b>D</b> Il nome del metodo ed il tipo, numero ed ordine dei parametri formali.
</li>
</ul>
<center><h3><b>Domanda 7</b></h3></center>
	<domanda>
		Si consideri il seguente frammento di codice Java:
<pre>
import java.util.*;
public class Test {
	public static void main(String[] args){
		List&lt;Integer&gt; l = new ArrayList&lt;Integer&gt;();
		l.add(new Integer(1));
		l.add(new Integer(2)); 
		l.add(new Integer(3));
		... // ISTRUZIONE A QUI
		while (i.hasNext()) {
			int q;
			... // ISTRUZIONE B QUI
			System.out.println(q*q);
		}
	}
}
</pre>
Mettendo al posto delle istruzioni mancanti le seguenti istruzioni A e B, una sola tra queste combinazione &egrave; errata e non produce il risultato di stampare i numeri 1, 4, 9. Quale?
Scegliere una risposta.

<ul>
<li><b>A</b> 		A: Iterator&lt;Integer&gt; i = l.iterator(); 
		B: q = i.next();

</li>
<li><b>B</b> 		A: Iterator i = l.iterator(); 
		B: q = (Integer)i.next();

</li>
<li><b>C</b> 		A: Iterator&lt;Object&gt; i = l.iterator(); 
		B: q = (Integer)i.next();

</li>
<li><b>D</b> 		A: Iterator&lt;Integer&gt; i = l.iterator(); 
		B: q = (int)i.next();

</li>
</ul>
<center><h3><b>Domanda 8</b></h3></center>
		Una sola delle seguenti affermazioni sull&#x27;uso dell&#x27;istruzione <tt>continue</tt> &egrave; vera. Quale?

<ul>
<li><b>A</b> 		L&#x27;istruzione continue causa sempre l&#x27;uscita dal ciclo all&#x27;interno del quale &egrave; invocata.
</li>
<li><b>B</b> 		L&#x27;istruzione continue pu&ograve; essere usata nel ramo if di un&#x27;istruzione <tt>if...else</tt> per passare al ramo <tt>else</tt>.
</li>
<li><b>C</b> 		L&#x27;istruzione continue permette di passare all&#x27;iterazione successiva del ciclo all&#x27;interno del quale &egrave; invocata.
</li>
<li><b>D</b> 		L&#x27;istruzione continue causa sempre l&#x27;uscita dal metodo all&#x27;interno del quale &egrave; invocata.
</li>
</ul>
<center><h3><b>Domanda 9</b></h3></center>
		A quale fra le seguenti categorie appartiene un grafo con n &gt; 1 nodi e m = 0 archi?

<ul>
<li><b>A</b> 		Grafo connesso
</li>
<li><b>B</b> 		Grafo fortemente connesso
</li>
<li><b>C</b> 		DAG
</li>
<li><b>D</b> 		Grafo completo
</li>
</ul>
<center><h3><b>Domanda 10</b></h3></center>
	<domanda>
		In una cache completamente associativa:

<ul>
<li><b>A</b> 		Nessuna delle precedenti
</li>
<li><b>B</b> 		Ogni blocco di memoria ha diversi possibili blocchi di cache che possono ospitarlo, ma non tutti
</li>
<li><b>C</b> 		Ogni blocco di memoria pu&ograve; essere ospitato in qualsiasi blocco di cache
</li>
<li><b>D</b> 		Ogni blocco di memoria ha un solo possibile blocco di cache che pu&ograve; ospitarlo
</li>
</ul>
</body></html>
