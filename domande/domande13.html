<!-- 13 -->
<html><HEAD><TITLE>Test VCA - test numero 13</TITLE><head><body>
<center><h2>Test VCA - test numero 13</h2></center><hr>
<center><h3><b>Domanda 1</b></h3></center>
	<domanda>
		Il luogo delle radici permette di individuare una compensazione atta

<ul>
<li><b>A</b> 		ad assegnare gli autovalori al sistema complessivo;
</li>
<li><b>B</b> 		ad aumentare il margine di guadagno del sistema complessivo. 
</li>
<li><b>C</b> 		ad aumentare il margine di fase del sistema complessivo;
</li>
<li><b>D</b> 		a stabilizzare asintoticamente il sistema complessivo;
</li>
</ul>
<center><h3><b>Domanda 2</b></h3></center>
	<domanda>
		Consideriamo la relazione <tt>Persona(nome,citta,eta)</tt>, che memorizza il nome, l&#x27;et&agrave; e la citt&agrave; di residenza delle persone. Per ogni citt&agrave;, si vuole calcolare il numero delle persone maggiorenni (la cui et&agrave; &egrave; maggiore di 18) che vivono in quella citt&agrave;. Una sola delle seguenti affermazioni &egrave;  vera. Quale?

<ul>
<li><b>A</b> 		La query SQL corretta &egrave;: 
<pre>
SELECT citta, count(*)
FROM Persona
WHERE eta &gt; 18
GROUP BY citta
</pre>
</li>
<li><b>B</b> 		La query SQL corretta &egrave;: 
<pre>
SELECT citta, count(*)
FROM Persona
GROUP BY citta
</pre>
</li>
<li><b>C</b> 		La query SQL corretta &egrave;:
<pre>
SELECT count(*)
FROM Persona
GROUP BY citta, eta
</pre>
</li>
<li><b>D</b> 		Non esiste alcuna query SQL che calcola i dati voluti;
</li>
</ul>
<center><h3><b>Domanda 3</b></h3></center>
	<domanda>
		In una cache completamente associativa:

<ul>
<li><b>A</b> 		Ogni blocco di memoria ha diversi possibili blocchi di cache che possono ospitarlo, ma non tutti
</li>
<li><b>B</b> 		Ogni blocco di memoria ha un solo possibile blocco di cache che pu&ograve; ospitarlo
</li>
<li><b>C</b> 		Nessuna delle precedenti
</li>
<li><b>D</b> 		Ogni blocco di memoria pu&ograve; essere ospitato in qualsiasi blocco di cache
</li>
</ul>
<center><h3><b>Domanda 4</b></h3></center>
	<domanda>
		Il massimo numero di nodi di un albero binario di altezza h &egrave;

<ul>
<li><b>A</b> 		2h
</li>
<li><b>B</b> 		2<sup>h+1</sup>-1
</li>
<li><b>C</b> 		&#x23A3;log<sub>2</sub> h&#x23A6;
</li>
<li><b>D</b> 		2<sup>h</sup>
</li>
</ul>
<center><h3><b>Domanda 5</b></h3></center>
		Quali tra le seguenti istruzioni dichiara e inizializza correttamente un array bidimensionale ? Scegliere una risposta.

<ul>
<li><b>A</b> 		int a[10][10] = new int[][];
</li>
<li><b>B</b> 		int [a][] = new int[10][10];
</li>
<li><b>C</b> 		int a[][] = new int[10,10]
</li>
<li><b>D</b> 		int a[][] = new int[10][10];
</li>
</ul>
<center><h3><b>Domanda 6</b></h3></center>
	<domanda>
Una sola delle seguenti affermazioni &egrave; corretta. Quale?

<ul>
<li><b>A</b> Per definire una classe <tt>C</tt> appartenente al package <tt>p</tt> &egrave; sufficiente scrivere la classe in un file contenente la dichiarazione <tt>class p.C { ... }</tt>
</li>
<li><b>B</b> Per definire una classe <tt>C</tt> appartenente al package <tt>p</tt> &egrave; sufficiente scrivere la classe in un file contenente la direttiva <tt>package p</tt>;
</li>
<li><b>C</b> Per definire una classe <tt>C</tt> appartenente al package <tt>p</tt> &egrave; sufficiente scrivere la classe in un file contenente la dichiarazione <tt>package p; class C { ... }</tt>
</li>
<li><b>D</b> Per definire una classe <tt>C</tt> appartenente al package <tt>p</tt> &egrave; sufficiente creare una directory <tt>p</tt> e scrivere la classe in un file all&#x27;interno della directory <tt>p</tt> contenente la dichiarazione <tt>package p; class C { ... }</tt>;
</li>
</ul>
<center><h3><b>Domanda 7</b></h3></center>
		Da un punto di vista prestazionale, un modo di trasferimento in rete di tipo a pacchetto &egrave; indicato

<ul>
<li><b>A</b> 		soprattutto quando le sorgenti di traffico sono prevalentemente continue (es: voce o streaming)
</li>
<li><b>B</b> 		in qualsiasi circostanza, indipendentemente dal tipo di traffico offerto dalle sorgenti
</li>
<li><b>C</b> 		soprattutto quando le sorgenti di traffico emettono ad alto ritmo binario
</li>
<li><b>D</b> 		soprattutto quando le sorgenti di traffico sono prevalentemente intermittenti (es: dati On-Off)
</li>
</ul>
<center><h3><b>Domanda 8</b></h3></center>
	<domanda>
Si consideri la classe <tt>ProvaInit</tt>, riportata di seguito:
<pre>
public class ProvaInit {
	private int x, y;
	public int somma () {return x+y; }
	public static void main (String[] args) {
		ProvaInit p=new ProvaInit ();
		p.x=10;
		System.out.println (p.somma ());
	}
}
</pre>
Una sola delle seguenti affermazioni &egrave; vera. Quale?

<ul>
<li><b>A</b> 		La classe causa un errore a tempo di esecuzione, perche&#x301; la variabile <tt>y</tt> non &egrave; inizializzata.
</li>
<li><b>B</b> 		La classe causa un errore a tempo di compilazione, perche&#x301; la variabile <tt>y</tt> non &egrave; inizializzata.
</li>
<li><b>C</b> 		La classe causa un errore a tempo di compilazione, perche&#x301; la variabile <tt>x</tt> &egrave; privata e non vi si pu&ograve; accedere dal metodo <tt>main</tt>.
</li>
<li><b>D</b> 		La classe compila correttamente. L&#x27;esecuzione del metodo <tt>main</tt> stampa <tt>10</tt>, perche&#x301; la variabile di istanza <tt>y</tt> viene automaticamente inizializzata a <tt>0</tt>.
</li>
</ul>
<center><h3><b>Domanda 9</b></h3></center>
Quali delle seguenti affermazioni relative al ciclo while &egrave; errata?

<ul>
<li><b>A</b> Qualunque sia il codice che definisce il ciclo &egrave; sempre possibile scrivere un ciclo do...while() equivalente.
</li>
<li><b>B</b> All&#x27;interno del ciclo &egrave; sempre possibile utilizzare le istruzioni break e continue.
</li>
<li><b>C</b> Al termine del ciclo la condizione di guardia ha sempre valore false
</li>
<li><b>D</b> Le variabili utilizzate nella condizione di guardia del ciclo possono essere modificate nel corpo del ciclo stesso.
</li>
</ul>
<center><h3><b>Domanda 10</b></h3></center>
		Il minimo numero di foglie di un albero binario di n nodi &egrave;

<ul>
<li><b>A</b> 		1
</li>
<li><b>B</b> 		&#x23A3;log<sub>2</sub> n&#x23A6;
</li>
<li><b>C</b> 		n-1
</li>
<li><b>D</b> 		2<sup>n</sup>
</li>
</ul>
</body></html>
