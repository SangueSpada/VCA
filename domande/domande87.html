<!-- 87 -->
<html><HEAD><TITLE>Test VCA - test numero 87</TITLE><head><body>
<center><h2>Test VCA - test numero 87</h2></center><hr>
<center><h3><b>Domanda 1</b></h3></center>
	<domanda>
		Una sola delle seguenti affermazioni &egrave; vera. Quale? Una variabile locale &egrave; visibile:

<ul>
<li><b>A</b> 		in tutti i metodi della classe in cui la variabile appare.
</li>
<li><b>B</b> 		nel solo blocco di istruzioni <tt>{ ... }</tt> in cui la variabile appare.
</li>
<li><b>C</b> 		in tutte le classi del programma, purch&egrave; siano compilate nella stessa directory.
</li>
<li><b>D</b> 		nel solo metodo in cui la variabile appare.
</li>
</ul>
<center><h3><b>Domanda 2</b></h3></center>
	<domanda>
Una sola delle seguenti affermazioni &egrave; corretta. Quale?

<ul>
<li><b>A</b> Per definire una classe <tt>C</tt> appartenente al package <tt>p</tt> &egrave; sufficiente scrivere la classe in un file contenente la dichiarazione <tt>class p.C { ... }</tt>
</li>
<li><b>B</b> Per definire una classe <tt>C</tt> appartenente al package <tt>p</tt> &egrave; sufficiente scrivere la classe in un file contenente la direttiva <tt>package p</tt>;
</li>
<li><b>C</b> Per definire una classe <tt>C</tt> appartenente al package <tt>p</tt> &egrave; sufficiente scrivere la classe in un file contenente la dichiarazione <tt>package p; class C { ... }</tt>
</li>
<li><b>D</b> Per definire una classe <tt>C</tt> appartenente al package <tt>p</tt> &egrave; sufficiente creare una directory <tt>p</tt> e scrivere la classe in un file all&#x27;interno della directory <tt>p</tt> contenente la dichiarazione <tt>package p; class C { ... }</tt>;
</li>
</ul>
<center><h3><b>Domanda 3</b></h3></center>
	<domanda>
		Una sola delle seguenti affermazioni sull&#x27;operazione di full outer-join in SQL &egrave; corretta. Quale?

<ul>
<li><b>A</b> 		Quando i due operandi non hanno valori nulli, il full outer-join coincide con il join dei due operandi; 
</li>
<li><b>B</b> 		L&#x27;outer-join di due relazioni &egrave; una relazione in cui tutte le tuple del primo operando sono combinate con almeno una tupla del secondo operando;
</li>
<li><b>C</b> 		L&#x27;operazione di full outer-join elimina i duplicati di una relazione;
</li>
<li><b>D</b> 		Il full outer join si pu&ograve; eseguire solo se i due operandi hanno lo stesso schema di relazione.
</li>
</ul>
<center><h3><b>Domanda 4</b></h3></center>
	<domanda>
		Il segmento STACK di un processo mantiene:

<ul>
<li><b>A</b> 		I record di attivazione delle funzioni
</li>
<li><b>B</b> 		I blocchi allocati dinamicamente dal programma
</li>
<li><b>C</b> 		Le variabili con durata statica (es. variabili globali) di un programma
</li>
<li><b>D</b> 		Il codice eseguibile su cui &egrave; basato il processo
</li>
</ul>
<center><h3><b>Domanda 5</b></h3></center>
	<domanda>
		Si consideri il seguente frammento di codice Java:
<pre>
import java.util.*;
public class Test {
	public static void main(String[] args){
		List&lt;Integer&gt; l = new ArrayList&lt;Integer&gt;();
		l.add(new Integer(1));
		l.add(new Integer(2)); 
		l.add(new Integer(3));
		... // ISTRUZIONE A QUI
		while (i.hasNext()) {
			int q;
			... // ISTRUZIONE B QUI
			System.out.println(q*q);
		}
	}
}
</pre>
Mettendo al posto delle istruzioni mancanti le seguenti istruzioni A e B, una sola tra queste combinazione &egrave; errata e non produce il risultato di stampare i numeri 1, 4, 9. Quale?
Scegliere una risposta.

<ul>
<li><b>A</b> 		A: Iterator&lt;Object&gt; i = l.iterator(); 
		B: q = (Integer)i.next();

</li>
<li><b>B</b> 		A: Iterator i = l.iterator(); 
		B: q = (Integer)i.next();

</li>
<li><b>C</b> 		A: Iterator&lt;Integer&gt; i = l.iterator(); 
		B: q = (int)i.next();

</li>
<li><b>D</b> 		A: Iterator&lt;Integer&gt; i = l.iterator(); 
		B: q = i.next();

</li>
</ul>
<center><h3><b>Domanda 6</b></h3></center>
	<domanda>
		La stabilit&agrave; interna di un sistema lineare

<ul>
<li><b>A</b> 		riguarda la limitatezza delle uscite rispetto all&rsquo;ingresso;
</li>
<li><b>B</b> 		&egrave; una propriet&agrave; delle evoluzioni libere nello stato;
</li>
<li><b>C</b> 		&egrave; assicurata dalla raggiungibilit&agrave; e osservabilit&agrave; del sistema.
</li>
<li><b>D</b> 		dipende dal segno della parte reale dei poli della funzione di trasferimento;
</li>
</ul>
<center><h3><b>Domanda 7</b></h3></center>
Quali delle seguenti affermazioni relative al ciclo while &egrave; errata?

<ul>
<li><b>A</b> Qualunque sia il codice che definisce il ciclo &egrave; sempre possibile scrivere un ciclo do...while() equivalente.
</li>
<li><b>B</b> Le variabili utilizzate nella condizione di guardia del ciclo possono essere modificate nel corpo del ciclo stesso.
</li>
<li><b>C</b> Al termine del ciclo la condizione di guardia ha sempre valore false
</li>
<li><b>D</b> All&#x27;interno del ciclo &egrave; sempre possibile utilizzare le istruzioni break e continue.
</li>
</ul>
<center><h3><b>Domanda 8</b></h3></center>
	<domanda>
		Qual &egrave; il minimo numero di nodi pozzo (grado di uscita = 0) in un DAG?

<ul>
<li><b>A</b> 		0
</li>
<li><b>B</b> 		2
</li>
<li><b>C</b> 		1
</li>
<li><b>D</b> 		3
</li>
</ul>
<center><h3><b>Domanda 9</b></h3></center>
		Il minimo numero di foglie di un albero binario di n nodi &egrave;

<ul>
<li><b>A</b> 		&#x23A3;log<sub>2</sub> n&#x23A6;
</li>
<li><b>B</b> 		n-1
</li>
<li><b>C</b> 		2<sup>n</sup>
</li>
<li><b>D</b> 		1
</li>
</ul>
<center><h3><b>Domanda 10</b></h3></center>
	<domanda>
		Da un punto di vista prestazionale, un modo di trasferimento in rete di tipo a circuito &egrave; indicato

<ul>
<li><b>A</b> 		soprattutto quando le sorgenti di traffico sono prevalentemente intermittenti (es: dati On-Off)
</li>
<li><b>B</b> 		in qualsiasi circostanza, indipendentemente dal tipo di traffico offerto dalle sorgenti
</li>
<li><b>C</b> 		soprattutto quando le sorgenti di traffico emettono a basso ritmo binario
</li>
<li><b>D</b> 		soprattutto quando le sorgenti di traffico sono prevalentemente continue (es: voce o streaming)
</li>
</ul>
</body></html>
