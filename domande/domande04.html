<!-- 4 -->
<html><HEAD><TITLE>Test VCA - test numero 4</TITLE><head><body>
<center><h2>Test VCA - test numero 4</h2></center><hr>
<center><h3><b>Domanda 1</b></h3></center>
	<domanda>
		A cosa serve in una rete in area locale (LAN) un protocollo di accesso multiplo?

<ul>
<li><b>A</b> 		ad evitare che utenti differenti collidano durante la trasmissione su una risorsa comune (es. canale di comunicazione)
</li>
<li><b>B</b> 		ad instradare le unit&agrave; informative nella LAN
</li>
<li><b>C</b> 		a velocizzare la comunicazione attraverso una LAN
</li>
<li><b>D</b> 		a permettere ad utenti differenti la condivisione di una risorsa comune (es. canale di comunicazione) 
</li>
</ul>
<center><h3><b>Domanda 2</b></h3></center>
	<domanda>
		Qual &egrave; il costo di cancellazione di una chiave in un albero di ricerca binario (BST)? 

<ul>
<li><b>A</b> 		O(log n)
</li>
<li><b>B</b> 		O(n log n)
</li>
<li><b>C</b> 		O(1)
</li>
<li><b>D</b> 		O(n)
</li>
</ul>
<center><h3><b>Domanda 3</b></h3></center>
	<domanda>
		La fase di progettazione logica di basi di dati procede attraverso i passi di ristrutturazione dello schema concettuale, traduzione diretta e ristrutturazione dello schema logico. Una sola delle seguenti affermazioni sulla progettazione logica &egrave; corretta. Quale?

<ul>
<li><b>A</b> 		La ristrutturazione dello schema concettuale ha lo scopo di ottimizzare le tabelle relazionali;
</li>
<li><b>B</b> 		La traduzione diretta ha lo scopo di derivare lo schema logico corrispondente allo schema concettuale ristrutturato, traducendo ogni entit&agrave; in una tabella, ed ogni relazione non accorpata in una tabella.
</li>
<li><b>C</b> 		Dopo la traduzione diretta non ci sono tabelle relazionali che ammettono valori nulli nei propri attributi;
</li>
<li><b>D</b> 		La ristrutturazione dello schema logico si effettua solo se ci sono attributi composti, attributi multivalore o relazioni ISA nello schema concettuale;
</li>
</ul>
<center><h3><b>Domanda 4</b></h3></center>
	<domanda>
		Si consideri il seguente frammento di codice Java:
<pre>
import java.util.*;
public class Test {
	public static void main(String[] args){
		List&lt;Integer&gt; l = new ArrayList&lt;Integer&gt;();
		l.add(new Integer(1));
		l.add(new Integer(2)); 
		l.add(new Integer(3));
		... // ISTRUZIONE A QUI
		while (i.hasNext()) {
			int q;
			... // ISTRUZIONE B QUI
			System.out.println(q*q);
		}
	}
}
</pre>
Mettendo al posto delle istruzioni mancanti le seguenti istruzioni A e B, una sola tra queste combinazione &egrave; errata e non produce il risultato di stampare i numeri 1, 4, 9. Quale?
Scegliere una risposta.

<ul>
<li><b>A</b> 		A: Iterator&lt;Integer&gt; i = l.iterator(); 
		B: q = i.next();

</li>
<li><b>B</b> 		A: Iterator i = l.iterator(); 
		B: q = (Integer)i.next();

</li>
<li><b>C</b> 		A: Iterator&lt;Integer&gt; i = l.iterator(); 
		B: q = (int)i.next();

</li>
<li><b>D</b> 		A: Iterator&lt;Object&gt; i = l.iterator(); 
		B: q = (Integer)i.next();

</li>
</ul>
<center><h3><b>Domanda 5</b></h3></center>
	<domanda>
Una sola delle seguenti affermazioni &egrave; corretta. Quale?

<ul>
<li><b>A</b> La direttiva <tt>package auto.utilita;</tt> pu&ograve; essere presente prima della dichiarazione di una qualsiasi classe in un file Java contenuto in una qualsiasi directory.
</li>
<li><b>B</b> La direttiva <tt>package auto.utilita;</tt> pu&ograve; essere presente prima della dichiarazione di una qualsiasi classe in un file Java contenuto in una directory <tt>auto\utilita</tt>.
</li>
<li><b>C</b> La direttiva <tt>package auto.utilita;</tt> deve essere la prima dichiarazione di un file Java contenuto in una directory <tt>auto\utilita</tt>.
</li>
<li><b>D</b> La direttiva <tt>package auto.utilita;</tt> deve essere la prima dichiarazione di un file Java contenuto in una qualsiasi directory.
</li>
</ul>
<center><h3><b>Domanda 6</b></h3></center>
	<domanda>
		Una sola delle seguenti affermazioni &egrave; vera. Quale? Il tempo di vita di una variabile statica coincide con il tempo di vita:

<ul>
<li><b>A</b> 		del metodo che la accede pi&ugrave; frequentemente.
</li>
<li><b>B</b> 		della classe a cui appartiene.
</li>
<li><b>C</b> 		del metodo che per primo la accede.
</li>
<li><b>D</b> 		dell&#x27;oggetto a cui appartiene.
</li>
</ul>
<center><h3><b>Domanda 7</b></h3></center>
	<domanda>
		Quali di queste specifiche pu&ograve; essere in generale soddisfatta in un sistema tempo discreto e non in un sistema tempo continuo?

<ul>
<li><b>A</b> 		errore nullo in tempo finito corrispondente ad un ingresso a gradino;
</li>
<li><b>B</b> 		errore  nullo a regime permanente corrispondente ad un ingresso a gradino;
</li>
<li><b>C</b> 		autovalori del sistema complessivo coincidenti con dei valori assegnati. 
</li>
<li><b>D</b> 		sistema complessivo asintoticamente stabile;
</li>
</ul>
<center><h3><b>Domanda 8</b></h3></center>
	<domanda>
Si consideri il seguente frammento di programma Java
<pre>
class Nodo {
	public Nodo next;
	public Object elem;
	public Nodo(Object e, Nodo n) {
		elem=e; next=n;
	}
	public String toString() {
		if (next==null) return elem.toString();
		else return elem+" "+this.next;
	} 
}
public class Test {
	public static void main(String[] args) {
		Nodo init = new Nodo("A",new Nodo("B",new Nodo("C",null)));
		System.out.println(init);
	}
}
</pre>
Una sola delle seguenti affermazioni &egrave; corretta. Quale?

<ul>
<li><b>A</b> Il frammento di codice contiene errori sintattici.
</li>
<li><b>B</b> Il programma &egrave; eseguito correttamente e stampa <tt>A null</tt>
</li>
<li><b>C</b> Il programma &egrave; eseguito correttamente e stampa <tt>A B C</tt>
</li>
<li><b>D</b> Il programma &egrave; eseguito correttamente e stampa <tt>A B</tt>
</li>
</ul>
<center><h3><b>Domanda 9</b></h3></center>
	<domanda>
		Quale tipologia di visita di un albero non &egrave; in profondit&agrave;? 

<ul>
<li><b>A</b> 		In ordine posticipato (post-order)
</li>
<li><b>B</b> 		In ordine simmetrico (in-order)
</li>
<li><b>C</b> 		In ampiezza
</li>
<li><b>D</b> 		In ordine anticipato (pre-order)
</li>
</ul>
<center><h3><b>Domanda 10</b></h3></center>
	<domanda>
		In una cache completamente associativa:

<ul>
<li><b>A</b> 		Ogni blocco di memoria ha un solo possibile blocco di cache che pu&ograve; ospitarlo
</li>
<li><b>B</b> 		Ogni blocco di memoria ha diversi possibili blocchi di cache che possono ospitarlo, ma non tutti
</li>
<li><b>C</b> 		Nessuna delle precedenti
</li>
<li><b>D</b> 		Ogni blocco di memoria pu&ograve; essere ospitato in qualsiasi blocco di cache
</li>
</ul>
</body></html>
