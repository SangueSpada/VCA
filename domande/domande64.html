<!-- 64 -->
<html><HEAD><TITLE>Test VCA - test numero 64</TITLE><head><body>
<center><h2>Test VCA - test numero 64</h2></center><hr>
<center><h3><b>Domanda 1</b></h3></center>
	<domanda>
Si consideri la seguente definizione del metodo <tt>modificaNumeriPari</tt>:
<pre>
public static int[] modificaNumeriPari(int[] dati, double[] delta, int num) {
	//Altro codice qui...
}
</pre>
Quale dei seguenti metodi non sovraccarica (overload) correttamente il metodo generando quindi un errore in fase di compilazione ?

<ul>
<li><b>A</b> <pre>
public double[] modificaNumeriPari(int[] dati, double[] delta, int num) {
	//Altro codice qui...
}
</pre>
</li>
<li><b>B</b> <pre>
public static void modificaNumeriPari(int[] dati) {
	//Altro codice qui...
}
</pre>
</li>
<li><b>C</b> <pre>
public int[] modificaNumeriPari(int[] dati, double[] delta) {
	//Altro codice qui...
}
</pre>
</li>
<li><b>D</b> <pre>
public static int[] modificaNumeriPari(int[] dati, int num, double[] delta) {
	//Altro codice qui...
}
</pre>
</li>
</ul>
<center><h3><b>Domanda 2</b></h3></center>
	<domanda>
		In una cache completamente associativa:

<ul>
<li><b>A</b> 		Ogni blocco di memoria ha diversi possibili blocchi di cache che possono ospitarlo, ma non tutti
</li>
<li><b>B</b> 		Ogni blocco di memoria pu&ograve; essere ospitato in qualsiasi blocco di cache
</li>
<li><b>C</b> 		Nessuna delle precedenti
</li>
<li><b>D</b> 		Ogni blocco di memoria ha un solo possibile blocco di cache che pu&ograve; ospitarlo
</li>
</ul>
<center><h3><b>Domanda 3</b></h3></center>
	<domanda>
		La stabilit&agrave; interna di un sistema lineare

<ul>
<li><b>A</b> 		&egrave; una propriet&agrave; delle evoluzioni libere nello stato;
</li>
<li><b>B</b> 		riguarda la limitatezza delle uscite rispetto all&rsquo;ingresso;
</li>
<li><b>C</b> 		dipende dal segno della parte reale dei poli della funzione di trasferimento;
</li>
<li><b>D</b> 		&egrave; assicurata dalla raggiungibilit&agrave; e osservabilit&agrave; del sistema.
</li>
</ul>
<center><h3><b>Domanda 4</b></h3></center>
	<domanda>
		Una sola delle seguenti affermazioni &egrave; vera. Quale? Una variabile locale &egrave; visibile:

<ul>
<li><b>A</b> 		nel solo metodo in cui la variabile appare.
</li>
<li><b>B</b> 		in tutti i metodi della classe in cui la variabile appare.
</li>
<li><b>C</b> 		in tutte le classi del programma, purch&egrave; siano compilate nella stessa directory.
</li>
<li><b>D</b> 		nel solo blocco di istruzioni <tt>{ ... }</tt> in cui la variabile appare.
</li>
</ul>
<center><h3><b>Domanda 5</b></h3></center>
	<domanda>
		Il massimo numero di nodi di un albero binario di altezza h &egrave;

<ul>
<li><b>A</b> 		2h
</li>
<li><b>B</b> 		&#x23A3;log<sub>2</sub> h&#x23A6;
</li>
<li><b>C</b> 		2<sup>h+1</sup>-1
</li>
<li><b>D</b> 		2<sup>h</sup>
</li>
</ul>
<center><h3><b>Domanda 6</b></h3></center>
	<domanda>
		La nozione di &quot;relazione&quot; &egrave; alla base del modello relazionale dei dati. Una sola delle seguenti affermazioni &egrave; vera. Quale?

<ul>
<li><b>A</b> 		Una relazione nel modello relazionale &egrave; definita come una relaziona matematica, ma con la differenza che le tuple che compongono la relazione (dette tuple) sono ordinate;
</li>
<li><b>B</b> 		Una relazione nel modello relazionale &egrave; definita come una relazione matematica, ovvero come un sottoinsieme del prodotto cartesiano di N insiemi di valori, dove N &egrave; il grado della relazione;
</li>
<li><b>C</b> 		Una relazione nel modello relazionale &egrave; una tabella che pu&ograve; essere anche infinita;
</li>
<li><b>D</b> 		Una relazione nel modello relazionale &egrave; un multiinsieme di tuple.
</li>
</ul>
<center><h3><b>Domanda 7</b></h3></center>
	<domanda>
		Si consideri il seguente frammento di codice Java:
<pre>
import java.util.*;
public class Test {
	public static void main(String[] args){
		List&lt;Integer&gt; l = new ArrayList&lt;Integer&gt;();
		l.add(new Integer(1));
		l.add(new Integer(2)); 
		l.add(new Integer(3));
		... // ISTRUZIONE A QUI
		while (i.hasNext()) {
			int q;
			... // ISTRUZIONE B QUI
			System.out.println(q*q);
		}
	}
}
</pre>
Mettendo al posto delle istruzioni mancanti le seguenti istruzioni A e B, una sola tra queste combinazione &egrave; errata e non produce il risultato di stampare i numeri 1, 4, 9. Quale?
Scegliere una risposta.

<ul>
<li><b>A</b> 		A: Iterator&lt;Integer&gt; i = l.iterator(); 
		B: q = i.next();

</li>
<li><b>B</b> 		A: Iterator&lt;Integer&gt; i = l.iterator(); 
		B: q = (int)i.next();

</li>
<li><b>C</b> 		A: Iterator i = l.iterator(); 
		B: q = (Integer)i.next();

</li>
<li><b>D</b> 		A: Iterator&lt;Object&gt; i = l.iterator(); 
		B: q = (Integer)i.next();

</li>
</ul>
<center><h3><b>Domanda 8</b></h3></center>
	<domanda>
		La chiusura transitiva di un DAG (grafo diretto aciclico) &egrave; un

<ul>
<li><b>A</b> 		grafo semplice
</li>
<li><b>B</b> 		DAG
</li>
<li><b>C</b> 		grafo orientato completo
</li>
<li><b>D</b> 		grafo diretto con cicli
</li>
</ul>
<center><h3><b>Domanda 9</b></h3></center>
	<domanda>
Si consideri il seguente metodo per il calcolo del fattoriale
<pre>
public static long fattoriale(long n) {
	if (n == 0)
		return 1;
	else
		return n * fattoriale(n-1);
}
</pre>
Solo una delle seguenti affermazioni &egrave; vera. Dire quale.

<ul>
<li><b>A</b> Non &egrave; possibile stabilire a priori se il record di attivazione relativo a <tt>fattoriale(3)</tt> venga rimosso dallo stack prima di quello relativo a <tt>fattoriale(2)</tt>, in quanto ci&ograve; dipende dal valore di <tt>n</tt>.
</li>
<li><b>B</b> Il record di attivazione relativo a <tt>fattoriale(2)</tt> viene sempre rimosso dallo stack prima del record di attivazione relativo a <tt>fattoriale(3)</tt>.
</li>
<li><b>C</b> Il record di attivazione relativo a <tt>fattoriale(3)</tt> viene rimosso dallo stack prima del record di attivazione relativo a <tt>fattoriale(2)</tt>.
</li>
<li><b>D</b> Il record di attivazione relativo a <tt>fattoriale(3)</tt> pu&ograve; essere rimosso dallo stack prima del record di attivazione relativo a <tt>fattoriale(2)</tt> in casi particolari.
</li>
</ul>
<center><h3><b>Domanda 10</b></h3></center>
	<domanda>
		Le modulazioni numeriche in banda traslata si utilizzano per multiplare pi&ugrave; segnali numerici sullo stesso canale. 

<ul>
<li><b>A</b> 		Non esiste alcuna dipendenza tra la banda del segnale e il numero di segnali numero di segnali che possono essere trasmessi contemporaneamente
</li>
<li><b>B</b> 		A parit&agrave; di banda del canale, pi&ugrave; &egrave; larga l&rsquo;occupazione in banda del segnale, pi&ugrave; &egrave; alto il numero di segnali che possono essere trasmessi contemporaneamente
</li>
<li><b>C</b> 		A parit&agrave; di banda del canale, meno &egrave; larga l&rsquo;occupazione in banda del segnale, pi&ugrave; &egrave; alto il numero di segnali che possono essere trasmessi contemporaneamente
</li>
<li><b>D</b> 		A parit&agrave; di banda del segnale, meno &egrave; larga l&rsquo;occupazione in banda del canale, pi&ugrave; &egrave; alto il numero di segnali che possono essere trasmessi contemporaneamente
</li>
</ul>
</body></html>
