<!-- 1 -->
<html><HEAD><TITLE>Test VCA - test numero 1</TITLE><head><body>
<center><h2>Test VCA - test numero 1</h2></center><hr>
<center><h3><b>Domanda 1</b></h3></center>
	<domanda>
		Quale delle seguenti proposizioni &egrave; errata?

<ul>
<li><b>A</b> 		a &or; b &equiv; &not;(&not;a &and; &not;b)
</li>
<li><b>B</b> 		a &and; b &equiv; &not;(&not;a &or; &not;b)
</li>
<li><b>C</b> 		a &#x27F7; b &equiv; &not;a &or; &not;b
</li>
<li><b>D</b> 		a &#x27F6; b &equiv; &not;a &or; b
</li>
</ul>
<center><h3><b>Domanda 2</b></h3></center>
	<domanda>
		L&rsquo;interfaccia tra un Host (terminale) di Internet e la sotto-rete cui &egrave; connesso:

<ul>
<li><b>A</b> 		pu&ograve; essere individuata dal solo indirizzo locale (es. indirizzo Ethernet) e non richiede un indirizzo IP globale
</li>
<li><b>B</b> 		deve essere individuata dall&rsquo; indirizzo IP solo se la sotto-rete comprende un numero elevato di Host
</li>
<li><b>C</b> 		deve essere individuata sia attraverso un indirizzo IP globale, che attraverso un indirizzo locale (es. indirizzo Ethernet)
</li>
<li><b>D</b> 		pu&ograve; essere individuata dal solo indirizzo IP globale e non richiede un indirizzo locale (es. indirizzo Ethernet)
</li>
</ul>
<center><h3><b>Domanda 3</b></h3></center>
		Quali tra le seguenti istruzioni dichiara e inizializza correttamente un array bidimensionale ? Scegliere una risposta.

<ul>
<li><b>A</b> 		int a[][] = new int[10,10]
</li>
<li><b>B</b> 		int a[10][10] = new int[][];
</li>
<li><b>C</b> 		int a[][] = new int[10][10];
</li>
<li><b>D</b> 		int [a][] = new int[10][10];
</li>
</ul>
<center><h3><b>Domanda 4</b></h3></center>
	<domanda>
Si consideri la seguente classe:
<pre>
public class Overloading{
	public void foo(String s) {}
	public void foo(String s, int i) {}
	public String foo(String s) {return s;}
}
</pre>
Una sola delle seguenti affermazioni &egrave; vera. Quale?

<ul>
<li><b>A</b> Il codice compila correttamente.
</li>
<li><b>B</b> Il compilatore da un errore di compilazione poich&egrave; i metodi hanno lo stesso nome.
</li>
<li><b>C</b> Il compilatore da un errore di compilazione poich&egrave; il corpo dei metodi &egrave; vuoto.
</li>
<li><b>D</b> Il compilatore da un errore di compilazione poich&egrave; il primo e l&#x27;ultimo metodo hanno la stessa firma.
</li>
</ul>
<center><h3><b>Domanda 5</b></h3></center>
	<domanda>
Si consideri la classe <tt>ProvaCiclo</tt>, riportata di seguito:
<pre>
import javax.swing.JOptionPane;
public class ProvaCiclo {
	public static void main (String[] args) {
		int i=Integer.parseInt (JOptionPane.showInputDialog ("Immetti un intero positivo"));
		while (i>0) {
			System.out.println (i);
			i--;
		}
	} 
}
</pre>
Una sola delle seguenti affermazioni &egrave; vera. Quale?

<ul>
<li><b>A</b> 		La classe <tt>ProvaCiclo</tt> causa un errore a tempo di compilazione, perche&#x301; non &egrave; possibile stabilire prima dell&#x27;esecuzione quante iterazioni verranno eseguite all&#x27;interno del metodo main.
</li>
<li><b>B</b> 		Se il numero immesso dall&#x27;utente &egrave; un intero positivo, vengono stampati gli interi da 1 ad i in ordine crescente.
</li>
<li><b>C</b> 		Il metodo <tt>main</tt> contiene un esempio di ciclo indefinito.
</li>
<li><b>D</b> 		Il metodo <tt>main</tt> contiene un esempio di ciclo definito.
</li>
</ul>
<center><h3><b>Domanda 6</b></h3></center>
	<domanda>
		La reificazione di una relazione &egrave; una operazione prevista nella metodologia di progettazione concettuale di basi di dati e consiste nella trasformazione di una relazione in una entit&agrave;.  Una sola delle seguenti affermazioni sulla reificazione di una relazione &egrave; corretta. Quale?

<ul>
<li><b>A</b> 		La reificazione di una relazione produce una nuove relazione in ISA con quella originaria;
</li>
<li><b>B</b> 		La reificazione di una relazione pu&ograve; essere applicata solo se la relazione non ha attributi;
</li>
<li><b>C</b> 		Se la relazione R ha n ruoli, allora la reificazione della relazione R produrr&agrave; una entit&agrave; che parteciper&agrave; ad n relazioni, dove ciascuna partecipazione sar&agrave; caratterizzata dalla cardinalit&agrave; (1,1);
</li>
<li><b>D</b> 		Se la relazione R &egrave; in ISA con un&#x27;altra relazione, allora non pu&ograve; essere oggetto di reificazione.  
</li>
</ul>
<center><h3><b>Domanda 7</b></h3></center>
	<domanda>
		Quali di queste affermazioni &egrave; vera per un sistema ad anello chiuso ed &egrave; falsa per un sistema ad anello aperto? 

<ul>
<li><b>A</b> 		il processo da controllare pu&ograve; avere una o pi&ugrave; ingressi, e una o pi&ugrave; uscite. 
</li>
<li><b>B</b> 		l&#x27;uscita del processo da controllare &egrave; misurabile ed &egrave; utilizzata dal controllore;
</li>
<li><b>C</b> 		l&#x27;uscita del controllore costituisce l&#x27;ingresso del processo da controllare;
</li>
<li><b>D</b> 		l&#x27;uscita del processo da controllare &egrave; misurabile;
</li>
</ul>
<center><h3><b>Domanda 8</b></h3></center>
	<domanda>
		Una sola delle seguenti affermazioni &egrave; vera. Quale? Una variabile locale &egrave; visibile:

<ul>
<li><b>A</b> 		nel solo metodo in cui la variabile appare.
</li>
<li><b>B</b> 		nel solo blocco di istruzioni <tt>{ ... }</tt> in cui la variabile appare.
</li>
<li><b>C</b> 		in tutti i metodi della classe in cui la variabile appare.
</li>
<li><b>D</b> 		in tutte le classi del programma, purch&egrave; siano compilate nella stessa directory.
</li>
</ul>
<center><h3><b>Domanda 9</b></h3></center>
	<domanda>
		La chiusura transitiva di un DAG (grafo diretto aciclico) &egrave; un

<ul>
<li><b>A</b> 		grafo diretto con cicli
</li>
<li><b>B</b> 		DAG
</li>
<li><b>C</b> 		grafo orientato completo
</li>
<li><b>D</b> 		grafo semplice
</li>
</ul>
<center><h3><b>Domanda 10</b></h3></center>
	<domanda>
		Si consideri un sistema con una piccola cache ad indirizzamento diretto contenente 2 sole
linee da 16 byte ciascuna. Quanti cache miss vengono generati dal seguente frammento di
programma? 
<pre>
int v[12];
v[0]=5;
v[1]=4;
v[10]=3;
v[8]=2;
v[2]=v[10];
v[9]=v[1];
</pre>
Assumere che l&rsquo;array v sia allineato a un indirizzo multiplo di 16 byte e che la
cache inizialmente non contenga alcun blocco di memoria in uso al processo.

<ul>
<li><b>A</b> 		4
</li>
<li><b>B</b> 		1
</li>
<li><b>C</b> 		2
</li>
<li><b>D</b> 		8
</li>
</ul>
</body></html>
