<!-- 24 -->
<html><HEAD><TITLE>Test VCA - test numero 24</TITLE><head><body>
<center><h2>Test VCA - test numero 24</h2></center><hr>
<center><h3><b>Domanda 1</b></h3></center>
	<domanda>
Si consideri la seguente classe:
<pre>
public class Overloading{
	public void foo(String s) {}
	public void foo(String s, int i) {}
	public String foo(String s) {return s;}
}
</pre>
Una sola delle seguenti affermazioni &egrave; vera. Quale?

<ul>
<li><b>A</b> Il codice compila correttamente.
</li>
<li><b>B</b> Il compilatore da un errore di compilazione poich&egrave; i metodi hanno lo stesso nome.
</li>
<li><b>C</b> Il compilatore da un errore di compilazione poich&egrave; il primo e l&#x27;ultimo metodo hanno la stessa firma.
</li>
<li><b>D</b> Il compilatore da un errore di compilazione poich&egrave; il corpo dei metodi &egrave; vuoto.
</li>
</ul>
<center><h3><b>Domanda 2</b></h3></center>
	<domanda>
		Qual &egrave; il costo di cancellazione di una chiave in un albero di ricerca binario (BST)? 

<ul>
<li><b>A</b> 		O(log n)
</li>
<li><b>B</b> 		O(n log n)
</li>
<li><b>C</b> 		O(1)
</li>
<li><b>D</b> 		O(n)
</li>
</ul>
<center><h3><b>Domanda 3</b></h3></center>
	<domanda>
		Quanto dovrebbe essere grande una tabella delle pagine per mappare uno spazio di memoria virtuale di 1 TB su uno spazio di memoria fisico di 4 GB con pagine di 1 KB?

<ul>
<li><b>A</b> 		1 GB
</li>
<li><b>B</b> 		4 GB
</li>
<li><b>C</b> 		512 MB
</li>
<li><b>D</b> 		128 MB
</li>
</ul>
<center><h3><b>Domanda 4</b></h3></center>
	<domanda>
		Da un punto di vista prestazionale, un modo di trasferimento in rete di tipo a circuito &egrave; indicato

<ul>
<li><b>A</b> 		in qualsiasi circostanza, indipendentemente dal tipo di traffico offerto dalle sorgenti
</li>
<li><b>B</b> 		soprattutto quando le sorgenti di traffico emettono a basso ritmo binario
</li>
<li><b>C</b> 		soprattutto quando le sorgenti di traffico sono prevalentemente continue (es: voce o streaming)
</li>
<li><b>D</b> 		soprattutto quando le sorgenti di traffico sono prevalentemente intermittenti (es: dati On-Off)
</li>
</ul>
<center><h3><b>Domanda 5</b></h3></center>
	<domanda>
		Quale tipologia di visita di un albero non &egrave; in profondit&agrave;? 

<ul>
<li><b>A</b> 		In ordine anticipato (pre-order)
</li>
<li><b>B</b> 		In ordine posticipato (post-order)
</li>
<li><b>C</b> 		In ampiezza
</li>
<li><b>D</b> 		In ordine simmetrico (in-order)
</li>
</ul>
<center><h3><b>Domanda 6</b></h3></center>
	<domanda>
Si consideri il seguente metodo Java:
<pre>
public static void cosaFa(int[] v, short y) {
	int i = 0;
	while (i&lt;v.length) v[++i] = y;
}
</pre>
Una sola delle seguenti affermazioni &egrave; vera. Quale?

<ul>
<li><b>A</b> 		Il metodo scrive il valore <tt>y</tt> in tutte le celle dell&#x27;array <tt>v</tt>.
</li>
<li><b>B</b> 		Il metodo genera una eccezione di tipo <tt>ArrayIndexOutOfBoundsException</tt>.
</li>
<li><b>C</b> 		Il metodo genera un errore di compilazione perch&egrave; <tt>length</tt> andrebbe scritto <tt>lenght</tt>
</li>
<li><b>D</b> 		Il metodo genera una eccezione di tipo <tt>PossibleLossOfPrecision</tt> poich&egrave; non &egrave; possibile assegnare uno <tt>short</tt> a una variabile <tt>int</tt>.
</li>
</ul>
<center><h3><b>Domanda 7</b></h3></center>
	<domanda>
		Siano <tt>R1(A1,A2)</tt> e <tt>R2(A1,A3)</tt> due schemi di relazione. Si consideri la seguente query espressa in SQL:
<pre>
SELECT *
FROM R1, R2
WHERE R1.A1=R2.A1
</pre>
Una sola delle seguenti affermazioni &egrave; vera. Quale?

<ul>
<li><b>A</b> 		la query corrisponde ad un&#x27;espressione dell&#x27;algebra relazionale in cui si usa una operazione di proiezione ed una operazione di selezione;
</li>
<li><b>B</b> 		la query corrisponde ad un&#x27;espressione dell&#x27;algebra relazionale in cui si usa la sola operazione di join naturale.
</li>
<li><b>C</b> 		la query corrisponde ad un&#x27;espressione dell&#x27;algebra relazionale in cui si usa la sola operazione di selezione dell&#x27;algebra relazionale;
</li>
<li><b>D</b> 		la query non corrisponde ad alcuna espressione dell&#x27;algebra relazionale;
</li>
</ul>
<center><h3><b>Domanda 8</b></h3></center>
	<domanda>
		Si consideri il seguente frammento di codice Java:
<pre>
import java.util.*;
public class Test {
	public static void main(String[] args){
		List&lt;Integer&gt; l = new ArrayList&lt;Integer&gt;();
		l.add(new Integer(1));
		l.add(new Integer(2)); 
		l.add(new Integer(3));
		... // ISTRUZIONE A QUI
		while (i.hasNext()) {
			int q;
			... // ISTRUZIONE B QUI
			System.out.println(q*q);
		}
	}
}
</pre>
Mettendo al posto delle istruzioni mancanti le seguenti istruzioni A e B, una sola tra queste combinazione &egrave; errata e non produce il risultato di stampare i numeri 1, 4, 9. Quale?
Scegliere una risposta.

<ul>
<li><b>A</b> 		A: Iterator&lt;Integer&gt; i = l.iterator(); 
		B: q = i.next();

</li>
<li><b>B</b> 		A: Iterator i = l.iterator(); 
		B: q = (Integer)i.next();

</li>
<li><b>C</b> 		A: Iterator&lt;Integer&gt; i = l.iterator(); 
		B: q = (int)i.next();

</li>
<li><b>D</b> 		A: Iterator&lt;Object&gt; i = l.iterator(); 
		B: q = (Integer)i.next();

</li>
</ul>
<center><h3><b>Domanda 9</b></h3></center>
	<domanda>
Si consideri la classe <tt>ProvaSwitch</tt>, riportata di seguito:
<pre>
public class ProvaSwitch {
	public static void conv(int x) {
		switch (x) {
			case 0:
				System.out.print ("Zero");
			case 1:
				System.out.print ("Uno");
				break;
			default:
				System.out.println ("Errore");
		} 
	}
	public static void main (String[] x) {
		for (int i=0; i<=2; i++)
			conv (i);
	}
}
</pre>
Una sola delle seguenti affermazioni &egrave; vera. Quale?

<ul>
<li><b>A</b> 		L'esecuzione del metodo <tt>main</tt> causa la stampa di <tt>ZeroUnoUnoErrore</tt>
</li>
<li><b>B</b> 		L'esecuzione del metodo <tt>main</tt> causa la stampa di <tt>ZeroUnoErrore</tt>
</li>
<li><b>C</b> 		L'esecuzione del metodo <tt>main</tt> causa la stampa di <tt>ZeroUnoDue</tt>
</li>
<li><b>D</b> 		L'esecuzione del metodo <tt>main</tt> causa la stampa di <tt>ZeroUno</tt>
</li>
</ul>
<center><h3><b>Domanda 10</b></h3></center>
	<domanda>
		La risposta a regime permanente

<ul>
<li><b>A</b> 		corrisponde necessariamente ad un ingresso persistente;
</li>
<li><b>B</b> 		esiste sempre ed &egrave; indipendente dallo stato iniziale.
</li>
<li><b>C</b> 		dipende dallo stato iniziale;
</li>
<li><b>D</b> 		&egrave; calcolata facendo il limite per t che tende all&rsquo;infinito;
</li>
</ul>
</body></html>
