<!-- 56 -->
<html><HEAD><TITLE>Test VCA - test numero 56</TITLE><head><body>
<center><h2>Test VCA - test numero 56</h2></center><hr>
<center><h3><b>Domanda 1</b></h3></center>
	<domanda>
		Quale delle seguenti asserzioni su un grafo semplice &egrave; <b>falsa</b>? (n = num. vertici, m = num. archi)

<ul>
<li><b>A</b> 		&Egrave; certamente connesso
</li>
<li><b>B</b> 		Il grado di un vertice pu&ograve; essere un qualunque numero in {0, 1, 2, &hellip;, n-1}
</li>
<li><b>C</b> 		La somma dei gradi dei vertici &egrave; 2m
</li>
<li><b>D</b> 		m &isin; O(n<sup>2</sup>)
</li>
</ul>
<center><h3><b>Domanda 2</b></h3></center>
	<domanda>
Una sola delle seguenti affermazioni &egrave; corretta. Quale?

<ul>
<li><b>A</b> Per definire una classe <tt>C</tt> appartenente al package <tt>p</tt> &egrave; sufficiente scrivere la classe in un file contenente la direttiva <tt>package p</tt>;
</li>
<li><b>B</b> Per definire una classe <tt>C</tt> appartenente al package <tt>p</tt> &egrave; sufficiente creare una directory <tt>p</tt> e scrivere la classe in un file all&#x27;interno della directory <tt>p</tt> contenente la dichiarazione <tt>package p; class C { ... }</tt>;
</li>
<li><b>C</b> Per definire una classe <tt>C</tt> appartenente al package <tt>p</tt> &egrave; sufficiente scrivere la classe in un file contenente la dichiarazione <tt>class p.C { ... }</tt>
</li>
<li><b>D</b> Per definire una classe <tt>C</tt> appartenente al package <tt>p</tt> &egrave; sufficiente scrivere la classe in un file contenente la dichiarazione <tt>package p; class C { ... }</tt>
</li>
</ul>
<center><h3><b>Domanda 3</b></h3></center>
	<domanda>
Si consideri la classe Prova cos&igrave; definita:
<pre>
private class Prova{
	public int x;
	public static int y;
}
</pre>
Una solo dei seguenti metodi non &egrave; corretto e non potrebbe apparire nella definizione di <tt>Prova</tt>. Quale?

<ul>
<li><b>A</b> <tt>public static void metodoC() {x++;}</tt>
</li>
<li><b>B</b> <tt>public void metodoB() {y++;}</tt>
</li>
<li><b>C</b> <tt>public static void metodoD() {y++;}</tt>
</li>
<li><b>D</b> <tt>public void metodoA() {x++;}</tt>
</li>
</ul>
<center><h3><b>Domanda 4</b></h3></center>
	<domanda>
		Siano <tt>R1(A1,A2)</tt> e <tt>R2(A1,A3)</tt> due schemi di relazione. Si consideri la seguente query espressa in SQL:
<pre>
SELECT *
FROM R1, R2
WHERE R1.A1=R2.A1
</pre>
Una sola delle seguenti affermazioni &egrave; vera. Quale?

<ul>
<li><b>A</b> 		la query corrisponde ad un&#x27;espressione dell&#x27;algebra relazionale in cui si usa una operazione di proiezione ed una operazione di selezione;
</li>
<li><b>B</b> 		la query corrisponde ad un&#x27;espressione dell&#x27;algebra relazionale in cui si usa la sola operazione di join naturale.
</li>
<li><b>C</b> 		la query corrisponde ad un&#x27;espressione dell&#x27;algebra relazionale in cui si usa la sola operazione di selezione dell&#x27;algebra relazionale;
</li>
<li><b>D</b> 		la query non corrisponde ad alcuna espressione dell&#x27;algebra relazionale;
</li>
</ul>
<center><h3><b>Domanda 5</b></h3></center>
	<domanda>
Si consideri la seguente espressione booleana:
<tt>!(a || b) && b</tt>
Una sola delle seguenti affermazioni &egrave; vera. Quale?

<ul>
<li><b>A</b> l&#x27;espressione restituisce sempre true.
</li>
<li><b>B</b> l&#x27;espressione restituisce true solo quando b==true e a==false.
</li>
<li><b>C</b> l&#x27;espressione restituisce sempre false.
</li>
<li><b>D</b> l&#x27;espressione restituisce true solo quando b==true.
</li>
</ul>
<center><h3><b>Domanda 6</b></h3></center>
	<domanda>
		Quale tipologia di visita di un albero di ricerca binario (BST) ne esamina la chiavi in ordine crescente? 

<ul>
<li><b>A</b> 		In ampiezza
</li>
<li><b>B</b> 		In profondit&agrave; con ordine anticipato (pre-order)
</li>
<li><b>C</b> 		In profondit&agrave; con ordine posticipato (post-order)
</li>
<li><b>D</b> 		In profondit&agrave; con ordine simmetrico (in-order)
</li>
</ul>
<center><h3><b>Domanda 7</b></h3></center>
	<domanda>
		Dato il seguente programma:
<pre>
import java.util.*; 
class Test {
	public static void main (String args[]) {
		Object a = new HashSet();
		System.out.print((a instanceof Set)+&quot;,&quot;);
		System.out.print(a instanceof SortedSet);
	}
}
</pre>
Qual&#x27;&egrave; il risultato della compilazione ed esecuzione del programma ?
Scegliere una risposta.

<ul>
<li><b>A</b> 		Stampa:false,true
</li>
<li><b>B</b> 		Stampa:true,false
</li>
<li><b>C</b> 		Stampa:true,true
</li>
<li><b>D</b> 		Stampa:false,false
</li>
</ul>
<center><h3><b>Domanda 8</b></h3></center>
	<domanda>
		Da un punto di vista prestazionale, un modo di trasferimento in rete di tipo a circuito &egrave; indicato

<ul>
<li><b>A</b> 		soprattutto quando le sorgenti di traffico emettono a basso ritmo binario
</li>
<li><b>B</b> 		soprattutto quando le sorgenti di traffico sono prevalentemente intermittenti (es: dati On-Off)
</li>
<li><b>C</b> 		soprattutto quando le sorgenti di traffico sono prevalentemente continue (es: voce o streaming)
</li>
<li><b>D</b> 		in qualsiasi circostanza, indipendentemente dal tipo di traffico offerto dalle sorgenti
</li>
</ul>
<center><h3><b>Domanda 9</b></h3></center>
		Qual'&egrave; il tempo tipico di accesso (latenza) a una memoria DRAM?

<ul>
<li><b>A</b> 		1-10 nanosecondi
</li>
<li><b>B</b> 		1-10 millisecondi
</li>
<li><b>C</b> 		1-10 microsecondi
</li>
<li><b>D</b> 		10-100 nanosecondi
</li>
</ul>
<center><h3><b>Domanda 10</b></h3></center>
		Gli autovalori di un sistema ad anello chiuso coincidono con 

<ul>
<li><b>A</b> 		i poli della funzione di trasferimento ad anello chiuso;
</li>
<li><b>B</b> 		i poli della funzione di trasferimento ad anello aperto.
</li>
<li><b>C</b> 		i poli della funzione di trasferimento ad anello aperto pi&ugrave; eventuali autovalori nascosti;
</li>
<li><b>D</b> 		i poli della funzione di trasferimento ad anello chiuso pi&ugrave; eventuali autovalori nascosti;
</li>
</ul>
</body></html>
