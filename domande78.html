<!-- 78 -->
<html><HEAD><TITLE>Test VCA - test numero 78</TITLE><head><body>
<center><h2>Test VCA - test numero 78</h2></center><hr>
<center><h3><b>Domanda 1</b></h3></center>
	<domanda>
		La funzione n! &egrave;

<ul>
<li><b>A</b> 		O(n<sup>n</sup>)
</li>
<li><b>B</b> 		O(n<sup>2</sup>)
</li>
<li><b>C</b> 		O(2<sup>n</sup>)
</li>
<li><b>D</b> 		O(log<sub>2</sub> n)
</li>
</ul>
<center><h3><b>Domanda 2</b></h3></center>
	<domanda>
		Una sola delle seguenti affermazioni &egrave; vera. Quale? Il tempo di vita di una variabile statica coincide con il tempo di vita:

<ul>
<li><b>A</b> 		del metodo che la accede pi&ugrave; frequentemente.
</li>
<li><b>B</b> 		dell&#x27;oggetto a cui appartiene.
</li>
<li><b>C</b> 		del metodo che per primo la accede.
</li>
<li><b>D</b> 		della classe a cui appartiene.
</li>
</ul>
<center><h3><b>Domanda 3</b></h3></center>
	<domanda>
		Una sola delle seguenti istruzioni compila correttamente senza generare errori o messaggi di avviso (warning). Quale ? (Si ricorda che ArrayList e LinkedList implementano l&#x27;interfaccia List e che List a sua volta estende l&#x27;interfaccia Collection)
Scegliere una risposta.

<ul>
<li><b>A</b> 		List&lt;Object&gt; x = new Collection&lt;Object&gt;();
</li>
<li><b>B</b> 		Collection&lt;?&gt; x = new ArrayList&lt;String&gt;();
</li>
<li><b>C</b> 		Collection&lt;Object&gt; x = new ArrayList&lt;String&gt;();
</li>
<li><b>D</b> 		List&lt;Object&gt; x = new LinkedList&lt;? extends Object&gt;();
</li>
</ul>
<center><h3><b>Domanda 4</b></h3></center>
	<domanda>
Si consideri la seguente definizione del metodo <tt>modificaNumeriPari</tt>:
<pre>
public static int[] modificaNumeriPari(int[] dati, double[] delta, int num) {
	//Altro codice qui...
}
</pre>
Quale dei seguenti metodi non sovraccarica (overload) correttamente il metodo generando quindi un errore in fase di compilazione ?

<ul>
<li><b>A</b> <pre>
public double[] modificaNumeriPari(int[] dati, double[] delta, int num) {
	//Altro codice qui...
}
</pre>
</li>
<li><b>B</b> <pre>
public int[] modificaNumeriPari(int[] dati, double[] delta) {
	//Altro codice qui...
}
</pre>
</li>
<li><b>C</b> <pre>
public static int[] modificaNumeriPari(int[] dati, int num, double[] delta) {
	//Altro codice qui...
}
</pre>
</li>
<li><b>D</b> <pre>
public static void modificaNumeriPari(int[] dati) {
	//Altro codice qui...
}
</pre>
</li>
</ul>
<center><h3><b>Domanda 5</b></h3></center>
	<domanda>
		La nozione di &quot;relazione&quot; &egrave; alla base del modello relazionale dei dati. Una sola delle seguenti affermazioni &egrave; vera. Quale?

<ul>
<li><b>A</b> 		Una relazione nel modello relazionale &egrave; un multiinsieme di tuple.
</li>
<li><b>B</b> 		Una relazione nel modello relazionale &egrave; definita come una relaziona matematica, ma con la differenza che le tuple che compongono la relazione (dette tuple) sono ordinate;
</li>
<li><b>C</b> 		Una relazione nel modello relazionale &egrave; definita come una relazione matematica, ovvero come un sottoinsieme del prodotto cartesiano di N insiemi di valori, dove N &egrave; il grado della relazione;
</li>
<li><b>D</b> 		Una relazione nel modello relazionale &egrave; una tabella che pu&ograve; essere anche infinita;
</li>
</ul>
<center><h3><b>Domanda 6</b></h3></center>
	<domanda>
		Il massimo numero di nodi di un albero binario di altezza h &egrave;

<ul>
<li><b>A</b> 		2h
</li>
<li><b>B</b> 		2<sup>h+1</sup>-1
</li>
<li><b>C</b> 		2<sup>h</sup>
</li>
<li><b>D</b> 		&#x23A3;log<sub>2</sub> h&#x23A6;
</li>
</ul>
<center><h3><b>Domanda 7</b></h3></center>
	<domanda>
		Una memoria cache &egrave; una memoria:

<ul>
<li><b>A</b> 		Lenta ed economica
</li>
<li><b>B</b> 		Veloce e costosa
</li>
<li><b>C</b> 		Veloce ed economica
</li>
<li><b>D</b> 		Lenta e costosa
</li>
</ul>
<center><h3><b>Domanda 8</b></h3></center>
	<domanda>
		Da un punto di vista prestazionale, un modo di trasferimento in rete di tipo a circuito &egrave; indicato

<ul>
<li><b>A</b> 		soprattutto quando le sorgenti di traffico sono prevalentemente intermittenti (es: dati On-Off)
</li>
<li><b>B</b> 		soprattutto quando le sorgenti di traffico emettono a basso ritmo binario
</li>
<li><b>C</b> 		soprattutto quando le sorgenti di traffico sono prevalentemente continue (es: voce o streaming)
</li>
<li><b>D</b> 		in qualsiasi circostanza, indipendentemente dal tipo di traffico offerto dalle sorgenti
</li>
</ul>
<center><h3><b>Domanda 9</b></h3></center>
	<domanda>
Si consideri il seguente metodo, assumendo che esso sia invocato con valore del parametro <tt>n > 0</tt>:
<pre>
public static long myfatt(long n) {
	if (n == 0)
		return 1;
	else
		return n * myfatt(n);
}
</pre>
Solo una delle seguenti affermazioni &egrave; vera. Dire quale.

<ul>
<li><b>A</b> Non &egrave; possibile stabilire a priori se il metodo determini un&#x27;eccezione o meno, in quanto tale evento dipende dal valore di <tt>n</tt>.
</li>
<li><b>B</b> Il metodo non &egrave; ricorsivo, in quanto tutte le invocazioni avvengono con lo stesso valore del parametro di ingresso.
</li>
<li><b>C</b> L&#x27;esecuzione del metodo causa un overflow dello stack della Java Virtual Machine in quanto determina un numero potenzialmente infinito di invocazioni ricorsive.
</li>
<li><b>D</b> Il metodo viene invocato ricorsivamente <tt>11</tt> volte.
</li>
</ul>
<center><h3><b>Domanda 10</b></h3></center>
	<domanda>
		In un sistema interconnesso

<ul>
<li><b>A</b> 		si pu&ograve; avere stabilit&agrave; interna in presenza di uno o pi&ugrave; sottosistemi instabili;
</li>
<li><b>B</b> 		la dimensione dello stato &egrave; pari alla soma delle dimensioni dei sottosistemi;
</li>
<li><b>C</b> 		l&rsquo;ingresso e sempre uguale alla somma degli ingressi;
</li>
<li><b>D</b> 		il numero delle uscite &egrave; sempre maggiore del numero degli ingressi.
</li>
</ul>
</body></html>
