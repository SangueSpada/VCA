<!-- 54 -->
<html><HEAD><TITLE>Test VCA - test numero 54</TITLE><head><body>
<center><h2>Test VCA - test numero 54</h2></center><hr>
<center><h3><b>Domanda 1</b></h3></center>
	<domanda>
		Un processo &egrave; stabilizzabile asintoticamente con reazione dall&#x27;uscita

<ul>
<li><b>A</b> 		se e solo se tutti i suoi autovalori sono a parte reale negativa;
</li>
<li><b>B</b> 		se e solo se tutti i suoi autovalori irraggiungibili e/o inosservabili sono a parte reale negativa;
</li>
<li><b>C</b> 		se e solo se tutti i suoi autovalori sono raggiungibili ed osservabili.
</li>
<li><b>D</b> 		se e solo se tutti i suoi autovalori raggiungibili ed osservabili sono a parte reale negativa;
</li>
</ul>
<center><h3><b>Domanda 2</b></h3></center>
	<domanda>
		In un albero binario completo di n nodi l&#x27;altezza &egrave;

<ul>
<li><b>A</b> 		&#x3F4;(log n)
</li>
<li><b>B</b> 		&#x3F4;(1)
</li>
<li><b>C</b> 		&#x3F4;(n log n)
</li>
<li><b>D</b> 		&#x3F4;(n)
</li>
</ul>
<center><h3><b>Domanda 3</b></h3></center>
	<domanda>
		Una sola delle seguenti istruzioni compila correttamente senza generare errori o messaggi di avviso (warning). Quale ? (Si ricorda che ArrayList e LinkedList implementano l&#x27;interfaccia List e che List a sua volta estende l&#x27;interfaccia Collection)
Scegliere una risposta.

<ul>
<li><b>A</b> 		List&lt;Object&gt; x = new LinkedList&lt;? extends Object&gt;();
</li>
<li><b>B</b> 		Collection&lt;Object&gt; x = new ArrayList&lt;String&gt;();
</li>
<li><b>C</b> 		Collection&lt;?&gt; x = new ArrayList&lt;String&gt;();
</li>
<li><b>D</b> 		List&lt;Object&gt; x = new Collection&lt;Object&gt;();
</li>
</ul>
<center><h3><b>Domanda 4</b></h3></center>
	<domanda>
		Una sola delle seguenti affermazioni sulla memoria virtuale &egrave; <b>falsa</b>. Quale?

<ul>
<li><b>A</b> 		Essendo basato su pagine tutte della stessa dimensione, consente di portare a zero il livello di frammentazione interna della memoria
</li>
<li><b>B</b> 		Separando lo spazio virtuale da quello fisico, si pu&ograve; fare in modo che un processo usi pi&ugrave; memoria di quella disponibile mappando pagine su disco invece che in RAM
</li>
<li><b>C</b> 		Tenendo distinti gli spazi virtuali (logici) di processi diversi, si impedisce che un processo possa interferire con le attivit&agrave; dell&rsquo;altro in modo errato o malizioso, realizzando un meccanismo di protezione
</li>
<li><b>D</b> 		Consentendo di mappare pagine di indirizzi virtuali di processi distinti sullo stesso frame fisico, la memoria virtuale consente la comunicazione e la cooperazione tra processi diversi
</li>
</ul>
<center><h3><b>Domanda 5</b></h3></center>
	<domanda>
		L&rsquo;elemento chiave per evitare il reiterarsi di collisioni in un accesso multiplo (MAC) casuale &egrave;:

<ul>
<li><b>A</b> 		la casualizzazione della durata dell&rsquo;intervallo di tempo di attesa prima di tentare la nuova emissione (noto come back-off)
</li>
<li><b>B</b> 		l&rsquo;aggiunta di un campo di rivelazione di errore nelle Unit&agrave; Dati MAC
</li>
<li><b>C</b> 		la possibilit&agrave; di ascoltare il mezzo multiaccesso per verificare la presenza di trasmissioni in corso prima di iniziare una nuova trasmissione
</li>
<li><b>D</b> 		effettuare un controllo centralizzato delle collisioni 
</li>
</ul>
<center><h3><b>Domanda 6</b></h3></center>
	<domanda>
Si consideri la seguente definizione del metodo <tt>modificaNumeriPari</tt>:
<pre>
public static int[] modificaNumeriPari(int[] dati, double[] delta, int num) {
	//Altro codice qui...
}
</pre>
Quale dei seguenti metodi non sovraccarica (overload) correttamente il metodo generando quindi un errore in fase di compilazione ?

<ul>
<li><b>A</b> <pre>
public static void modificaNumeriPari(int[] dati) {
	//Altro codice qui...
}
</pre>
</li>
<li><b>B</b> <pre>
public static int[] modificaNumeriPari(int[] dati, int num, double[] delta) {
	//Altro codice qui...
}
</pre>
</li>
<li><b>C</b> <pre>
public int[] modificaNumeriPari(int[] dati, double[] delta) {
	//Altro codice qui...
}
</pre>
</li>
<li><b>D</b> <pre>
public double[] modificaNumeriPari(int[] dati, double[] delta, int num) {
	//Altro codice qui...
}
</pre>
</li>
</ul>
<center><h3><b>Domanda 7</b></h3></center>
	<domanda>
		Quale fra le seguenti <b>di norma</b> non &egrave; una propriet&agrave; delle funzioni hash ? 

<ul>
<li><b>A</b> 		Iniettivit&agrave;
</li>
<li><b>B</b> 		Tempo di calcolo indipendente dal numero di chiavi in tabella
</li>
<li><b>C</b> 		Suriettivit&agrave;
</li>
<li><b>D</b> 		Determinismo
</li>
</ul>
<center><h3><b>Domanda 8</b></h3></center>
	<domanda>
		La fase di progettazione logica di basi di dati procede attraverso i passi di ristrutturazione dello schema concettuale, traduzione diretta e ristrutturazione dello schema logico. Una sola delle seguenti affermazioni sulla progettazione logica &egrave; corretta. Quale?

<ul>
<li><b>A</b> 		Dopo la traduzione diretta non ci sono tabelle relazionali che ammettono valori nulli nei propri attributi;
</li>
<li><b>B</b> 		La traduzione diretta ha lo scopo di derivare lo schema logico corrispondente allo schema concettuale ristrutturato, traducendo ogni entit&agrave; in una tabella, ed ogni relazione non accorpata in una tabella.
</li>
<li><b>C</b> 		La ristrutturazione dello schema concettuale ha lo scopo di ottimizzare le tabelle relazionali;
</li>
<li><b>D</b> 		La ristrutturazione dello schema logico si effettua solo se ci sono attributi composti, attributi multivalore o relazioni ISA nello schema concettuale;
</li>
</ul>
<center><h3><b>Domanda 9</b></h3></center>
	<domanda>
Si consideri la classe <tt>ProvaCiclo</tt>, riportata di seguito:
<pre>
import javax.swing.JOptionPane;
public class ProvaCiclo {
	public static void main (String[] args) {
		int i=Integer.parseInt (JOptionPane.showInputDialog ("Immetti un intero positivo"));
		while (i>0) {
			System.out.println (i);
			i--;
		}
	} 
}
</pre>
Una sola delle seguenti affermazioni &egrave; vera. Quale?

<ul>
<li><b>A</b> 		Il metodo <tt>main</tt> contiene un esempio di ciclo definito.
</li>
<li><b>B</b> 		La classe <tt>ProvaCiclo</tt> causa un errore a tempo di compilazione, perche&#x301; non &egrave; possibile stabilire prima dell&#x27;esecuzione quante iterazioni verranno eseguite all&#x27;interno del metodo main.
</li>
<li><b>C</b> 		Se il numero immesso dall&#x27;utente &egrave; un intero positivo, vengono stampati gli interi da 1 ad i in ordine crescente.
</li>
<li><b>D</b> 		Il metodo <tt>main</tt> contiene un esempio di ciclo indefinito.
</li>
</ul>
<center><h3><b>Domanda 10</b></h3></center>
	<domanda>
Si consideri il seguente frammento di codice:
<pre>
public class PezzoMusicale {
	public static void riproduci(PezzoMusicale i) {
		i.play();
	}
	public void play() {
		/* altro codice */
	}
}
</pre>
Quali delle seguenti istruzioni genera un errore in fase di compilazione ?

<ul>
<li><b>A</b> <pre>
PezzoMusicale canzone = new PezzoMusicale();
canzone.play();
</pre>
</li>
<li><b>B</b> <pre>
PezzoMusicale canzone = new PezzoMusicale();
PezzoMusicale.riproduci(canzone);
</pre>
</li>
<li><b>C</b> <pre>
PezzoMusicale canzone = new PezzoMusicale();
PezzoMusicale.play();
</pre>
</li>
<li><b>D</b> <pre>
PezzoMusicale canzone = new PezzoMusicale();
canzone.riproduci(canzone);
</pre>
</li>
</ul>
</body></html>
