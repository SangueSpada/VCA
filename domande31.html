<!-- 31 -->
<html><HEAD><TITLE>Test VCA - test numero 31</TITLE><head><body>
<center><h2>Test VCA - test numero 31</h2></center><hr>
<center><h3><b>Domanda 1</b></h3></center>
	<domanda>
		Il problema di trasporre una matrice quadrata ha costo computazionale (nella dimensione dell&#x27;input)

<ul>
<li><b>A</b> 		lineare
</li>
<li><b>B</b> 		logaritmico
</li>
<li><b>C</b> 		costante
</li>
<li><b>D</b> 		quadratico
</li>
</ul>
<center><h3><b>Domanda 2</b></h3></center>
	<domanda>
		Quale tipologia di visita di un albero non &egrave; in profondit&agrave;? 

<ul>
<li><b>A</b> 		In ordine simmetrico (in-order)
</li>
<li><b>B</b> 		In ordine posticipato (post-order)
</li>
<li><b>C</b> 		In ordine anticipato (pre-order)
</li>
<li><b>D</b> 		In ampiezza
</li>
</ul>
<center><h3><b>Domanda 3</b></h3></center>
	<domanda>
		In un sistema dinamico lineare

<ul>
<li><b>A</b> 		le evoluzioni in uscita soddisfano al principio di sovrapposizione degli effetti rispetto all&rsquo;ingresso;
</li>
<li><b>B</b> 		ammette un legame tra u(t) e y(t) del tipo y(t)= K(t) x u(t).
</li>
<li><b>C</b> 		la risposta si compone di una parte libera ed una forzata;
</li>
<li><b>D</b> 		la rappresentazione con lo stato &egrave; necessariamente lineare;
</li>
</ul>
<center><h3><b>Domanda 4</b></h3></center>
	<domanda>
Si consideri la classe <tt>ProvaSwitch</tt>, riportata di seguito:
<pre>
public class ProvaSwitch {
	public static void conv(int x) {
		switch (x) {
			case 0:
				System.out.print ("Zero");
			case 1:
				System.out.print ("Uno");
				break;
			default:
				System.out.println ("Errore");
		} 
	}
	public static void main (String[] x) {
		for (int i=0; i<=2; i++)
			conv (i);
	}
}
</pre>
Una sola delle seguenti affermazioni &egrave; vera. Quale?

<ul>
<li><b>A</b> 		L'esecuzione del metodo <tt>main</tt> causa la stampa di <tt>ZeroUnoUnoErrore</tt>
</li>
<li><b>B</b> 		L'esecuzione del metodo <tt>main</tt> causa la stampa di <tt>ZeroUnoDue</tt>
</li>
<li><b>C</b> 		L'esecuzione del metodo <tt>main</tt> causa la stampa di <tt>ZeroUnoErrore</tt>
</li>
<li><b>D</b> 		L'esecuzione del metodo <tt>main</tt> causa la stampa di <tt>ZeroUno</tt>
</li>
</ul>
<center><h3><b>Domanda 5</b></h3></center>
	<domanda>
		La fase di progettazione logica di basi di dati procede attraverso i passi di ristrutturazione dello schema concettuale, traduzione diretta e ristrutturazione dello schema logico. Una sola delle seguenti affermazioni sulla progettazione logica &egrave; corretta. Quale?

<ul>
<li><b>A</b> 		La ristrutturazione dello schema logico si effettua solo se ci sono attributi composti, attributi multivalore o relazioni ISA nello schema concettuale;
</li>
<li><b>B</b> 		La traduzione diretta ha lo scopo di derivare lo schema logico corrispondente allo schema concettuale ristrutturato, traducendo ogni entit&agrave; in una tabella, ed ogni relazione non accorpata in una tabella.
</li>
<li><b>C</b> 		Dopo la traduzione diretta non ci sono tabelle relazionali che ammettono valori nulli nei propri attributi;
</li>
<li><b>D</b> 		La ristrutturazione dello schema concettuale ha lo scopo di ottimizzare le tabelle relazionali;
</li>
</ul>
<center><h3><b>Domanda 6</b></h3></center>
	<domanda>
Si consideri la seguente definizione del metodo <tt>modificaNumeriPari</tt>:
<pre>
public static int[] modificaNumeriPari(int[] dati, double[] delta, int num) {
	//Altro codice qui...
}
</pre>
Quale dei seguenti metodi non sovraccarica (overload) correttamente il metodo generando quindi un errore in fase di compilazione ?

<ul>
<li><b>A</b> <pre>
public int[] modificaNumeriPari(int[] dati, double[] delta) {
	//Altro codice qui...
}
</pre>
</li>
<li><b>B</b> <pre>
public static void modificaNumeriPari(int[] dati) {
	//Altro codice qui...
}
</pre>
</li>
<li><b>C</b> <pre>
public double[] modificaNumeriPari(int[] dati, double[] delta, int num) {
	//Altro codice qui...
}
</pre>
</li>
<li><b>D</b> <pre>
public static int[] modificaNumeriPari(int[] dati, int num, double[] delta) {
	//Altro codice qui...
}
</pre>
</li>
</ul>
<center><h3><b>Domanda 7</b></h3></center>
	<domanda>
		A cosa serve in una rete in area locale (LAN) un protocollo di accesso multiplo?

<ul>
<li><b>A</b> 		ad evitare che utenti differenti collidano durante la trasmissione su una risorsa comune (es. canale di comunicazione)
</li>
<li><b>B</b> 		a velocizzare la comunicazione attraverso una LAN
</li>
<li><b>C</b> 		a permettere ad utenti differenti la condivisione di una risorsa comune (es. canale di comunicazione) 
</li>
<li><b>D</b> 		ad instradare le unit&agrave; informative nella LAN
</li>
</ul>
<center><h3><b>Domanda 8</b></h3></center>
	<domanda>
		Si consideri il seguente frammento di codice Java:
<pre>
import java.util.*;
public class Test {
	public static void main(String[] args){
		List&lt;Integer&gt; l = new ArrayList&lt;Integer&gt;();
		l.add(new Integer(1));
		l.add(new Integer(2)); 
		l.add(new Integer(3));
		... // ISTRUZIONE A QUI
		while (i.hasNext()) {
			int q;
			... // ISTRUZIONE B QUI
			System.out.println(q*q);
		}
	}
}
</pre>
Mettendo al posto delle istruzioni mancanti le seguenti istruzioni A e B, una sola tra queste combinazione &egrave; errata e non produce il risultato di stampare i numeri 1, 4, 9. Quale?
Scegliere una risposta.

<ul>
<li><b>A</b> 		A: Iterator&lt;Object&gt; i = l.iterator(); 
		B: q = (Integer)i.next();

</li>
<li><b>B</b> 		A: Iterator&lt;Integer&gt; i = l.iterator(); 
		B: q = (int)i.next();

</li>
<li><b>C</b> 		A: Iterator&lt;Integer&gt; i = l.iterator(); 
		B: q = i.next();

</li>
<li><b>D</b> 		A: Iterator i = l.iterator(); 
		B: q = (Integer)i.next();

</li>
</ul>
<center><h3><b>Domanda 9</b></h3></center>
	<domanda>
		Le variabili locali alle funzioni di un processo sono memorizzate nel segmento:

<ul>
<li><b>A</b> 		CODE
</li>
<li><b>B</b> 		STACK
</li>
<li><b>C</b> 		HEAP
</li>
<li><b>D</b> 		DATA
</li>
</ul>
<center><h3><b>Domanda 10</b></h3></center>
	<domanda>
		Si consideri la seguente espressione Java: <tt>a==b</tt>, dove <tt>a</tt> e <tt>b</tt> sono riferimenti ad array di <tt>int</tt>. Una sola delle seguenti affermazioni &egrave; vera. Quale?

<ul>
<li><b>A</b> 		L&#x27;espressione vale sempre <tt>false</tt>, indipendentemente dal contenuto di <tt>a</tt> e <tt>b</tt>.
</li>
<li><b>B</b> 		L&#x27;espressione vale <tt>true</tt> se <tt>a</tt> e <tt>b</tt> contengono lo stesso indirizzo, cio&egrave; puntano allo stesso array.
</li>
<li><b>C</b> 		L&#x27;espressione &egrave; errata poiche&#x301; l&#x27;operatore <tt>==</tt> non &egrave; applicabile a riferimenti ad array.
</li>
<li><b>D</b> 		L&#x27;espressione vale <tt>true</tt> se <tt>a</tt> e <tt>b</tt> sono riferimenti a due array che contengono gli stessi interi nello stesso ordine.
</li>
</ul>
</body></html>
