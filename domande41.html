<!-- 41 -->
<html><HEAD><TITLE>Test VCA - test numero 41</TITLE><head><body>
<center><h2>Test VCA - test numero 41</h2></center><hr>
<center><h3><b>Domanda 1</b></h3></center>
	<domanda>
		La fase di progettazione logica di basi di dati procede attraverso i passi di ristrutturazione dello schema concettuale, traduzione diretta e ristrutturazione dello schema logico. Una sola delle seguenti affermazioni sulla progettazione logica &egrave; corretta. Quale?

<ul>
<li><b>A</b> 		La ristrutturazione dello schema logico si effettua solo se ci sono attributi composti, attributi multivalore o relazioni ISA nello schema concettuale;
</li>
<li><b>B</b> 		Dopo la traduzione diretta non ci sono tabelle relazionali che ammettono valori nulli nei propri attributi;
</li>
<li><b>C</b> 		La ristrutturazione dello schema concettuale ha lo scopo di ottimizzare le tabelle relazionali;
</li>
<li><b>D</b> 		La traduzione diretta ha lo scopo di derivare lo schema logico corrispondente allo schema concettuale ristrutturato, traducendo ogni entit&agrave; in una tabella, ed ogni relazione non accorpata in una tabella.
</li>
</ul>
<center><h3><b>Domanda 2</b></h3></center>
	<domanda>
		In una architettura protocollare a strati di tipo OSI quale strato &egrave; generalmente responsabile di determinare il cammino migliore per instradare un pacchetto dati?

<ul>
<li><b>A</b> 		lo strato applicativo
</li>
<li><b>B</b> 		lo strato di rete
</li>
<li><b>C</b> 		lo strato fisico
</li>
<li><b>D</b> 		lo strato di trasporto
</li>
</ul>
<center><h3><b>Domanda 3</b></h3></center>
	<domanda>
Si consideri la seguente definizione del metodo <tt>modificaNumeriPari</tt>:
<pre>
public static int[] modificaNumeriPari(int[] dati, double[] delta, int num) {
	//Altro codice qui...
}
</pre>
Quale dei seguenti metodi non sovraccarica (overload) correttamente il metodo generando quindi un errore in fase di compilazione ?

<ul>
<li><b>A</b> <pre>
public static int[] modificaNumeriPari(int[] dati, int num, double[] delta) {
	//Altro codice qui...
}
</pre>
</li>
<li><b>B</b> <pre>
public static void modificaNumeriPari(int[] dati) {
	//Altro codice qui...
}
</pre>
</li>
<li><b>C</b> <pre>
public double[] modificaNumeriPari(int[] dati, double[] delta, int num) {
	//Altro codice qui...
}
</pre>
</li>
<li><b>D</b> <pre>
public int[] modificaNumeriPari(int[] dati, double[] delta) {
	//Altro codice qui...
}
</pre>
</li>
</ul>
<center><h3><b>Domanda 4</b></h3></center>
	<domanda>
		Quale tipologia di visita in profondit&agrave; di un albero risulta asintoticamente pi&ugrave; rapida? 

<ul>
<li><b>A</b> 		Tutte a pari merito 
</li>
<li><b>B</b> 		In ordine posticipato (post-order)
</li>
<li><b>C</b> 		In ordine anticipato (pre-order)
</li>
<li><b>D</b> 		In ordine simmetrico (in-order)
</li>
</ul>
<center><h3><b>Domanda 5</b></h3></center>
		Quali tra le seguenti istruzioni dichiara e inizializza correttamente un array bidimensionale ? Scegliere una risposta.

<ul>
<li><b>A</b> 		int [a][] = new int[10][10];
</li>
<li><b>B</b> 		int a[][] = new int[10,10]
</li>
<li><b>C</b> 		int a[10][10] = new int[][];
</li>
<li><b>D</b> 		int a[][] = new int[10][10];
</li>
</ul>
<center><h3><b>Domanda 6</b></h3></center>
	<domanda>
		Si consideri un sistema con una piccola cache completamente associativa contenente 2 sole
linee da 16 byte ciascuna. Quanti cache miss vengono generati dal seguente frammento di
programma? 
<pre>
int v[12];
v[0]=5;
v[1]=4;
v[10]=3;
v[8]=2;
v[2]=v[10];
v[9]=v[1];
</pre>
Assumere che l&rsquo;array v sia allineato a un indirizzo multiplo di 16 byte e che la
cache inizialmente non contenga alcun blocco di memoria in uso al processo.

<ul>
<li><b>A</b> 		1
</li>
<li><b>B</b> 		8
</li>
<li><b>C</b> 		5
</li>
<li><b>D</b> 		2
</li>
</ul>
<center><h3><b>Domanda 7</b></h3></center>
	<domanda>
		La risposta a regime permanente

<ul>
<li><b>A</b> 		&egrave; calcolata facendo il limite per t che tende all&rsquo;infinito;
</li>
<li><b>B</b> 		corrisponde necessariamente ad un ingresso persistente;
</li>
<li><b>C</b> 		esiste sempre ed &egrave; indipendente dallo stato iniziale.
</li>
<li><b>D</b> 		dipende dallo stato iniziale;
</li>
</ul>
<center><h3><b>Domanda 8</b></h3></center>
	<domanda>
		Qual &egrave; il minimo numero di nodi pozzo (grado di uscita = 0) in un DAG?

<ul>
<li><b>A</b> 		0
</li>
<li><b>B</b> 		2
</li>
<li><b>C</b> 		3
</li>
<li><b>D</b> 		1
</li>
</ul>
<center><h3><b>Domanda 9</b></h3></center>
Si consideri il seguente metodo per il calcolo del fattoriale
<pre>
public static long fattoriale(long n) {
	if (n == 0)
		return 1;
	else
		return n * fattoriale(n-1);
}
</pre>
Solo una delle seguenti affermazioni &egrave; vera. Dire quale.

<ul>
<li><b>A</b> Il numero di record di attivazione presenti nello stack quando il metodo viene invocato con valore <tt>0</tt> del parametro &egrave; <tt>n+1</tt>.
</li>
<li><b>B</b> Lo Stack della Java Virtual Machine contiene, ad ogni istante, soltanto un record di attivazione relativo al metodo.
</li>
<li><b>C</b> Non &egrave; possibile stabilire a priori il numero massimo di record di attivazione che saranno presenti nello stack in seguito all&#x27;invocazione del metodo.
</li>
<li><b>D</b> Il numero massimo di record di attivazione presenti nello stack a seguito dell&#x27;invocazione del metodo non dipende da <tt>n</tt>.
</li>
</ul>
<center><h3><b>Domanda 10</b></h3></center>
		Una sola delle seguenti affermazioni sull&#x27;uso dell&#x27;istruzione <tt>continue</tt> &egrave; vera. Quale?

<ul>
<li><b>A</b> 		L&#x27;istruzione continue permette di passare all&#x27;iterazione successiva del ciclo all&#x27;interno del quale &egrave; invocata.
</li>
<li><b>B</b> 		L&#x27;istruzione continue causa sempre l&#x27;uscita dal ciclo all&#x27;interno del quale &egrave; invocata.
</li>
<li><b>C</b> 		L&#x27;istruzione continue pu&ograve; essere usata nel ramo if di un&#x27;istruzione <tt>if...else</tt> per passare al ramo <tt>else</tt>.
</li>
<li><b>D</b> 		L&#x27;istruzione continue causa sempre l&#x27;uscita dal metodo all&#x27;interno del quale &egrave; invocata.
</li>
</ul>
</body></html>
