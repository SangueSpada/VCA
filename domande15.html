<!-- 15 -->
<html><HEAD><TITLE>Test VCA - test numero 15</TITLE><head><body>
<center><h2>Test VCA - test numero 15</h2></center><hr>
<center><h3><b>Domanda 1</b></h3></center>
	<domanda>
		Quale tipologia di visita in profondit&agrave; di un albero risulta asintoticamente pi&ugrave; rapida? 

<ul>
<li><b>A</b> 		Tutte a pari merito 
</li>
<li><b>B</b> 		In ordine anticipato (pre-order)
</li>
<li><b>C</b> 		In ordine simmetrico (in-order)
</li>
<li><b>D</b> 		In ordine posticipato (post-order)
</li>
</ul>
<center><h3><b>Domanda 2</b></h3></center>
		Quali tra le seguenti istruzioni dichiara e inizializza correttamente un array bidimensionale ? Scegliere una risposta.

<ul>
<li><b>A</b> 		int [a][] = new int[10][10];
</li>
<li><b>B</b> 		int a[][] = new int[10,10]
</li>
<li><b>C</b> 		int a[10][10] = new int[][];
</li>
<li><b>D</b> 		int a[][] = new int[10][10];
</li>
</ul>
<center><h3><b>Domanda 3</b></h3></center>
	<domanda>
		In un sistema dinamico lineare

<ul>
<li><b>A</b> 		la risposta si compone di una parte libera ed una forzata;
</li>
<li><b>B</b> 		ammette un legame tra u(t) e y(t) del tipo y(t)= K(t) x u(t).
</li>
<li><b>C</b> 		le evoluzioni in uscita soddisfano al principio di sovrapposizione degli effetti rispetto all&rsquo;ingresso;
</li>
<li><b>D</b> 		la rappresentazione con lo stato &egrave; necessariamente lineare;
</li>
</ul>
<center><h3><b>Domanda 4</b></h3></center>
	<domanda>
		Una sola delle seguenti affermazioni sul passaggio dei parametri in Java &egrave; vera. Quale? Al momento dell&#x27;invocazione di un metodo:

<ul>
<li><b>A</b> 		i parametri attuali dell&#x27;invocazione vengono copiati nei corrispondenti parametri formali dell&#x27;intestazione del metodo.
</li>
<li><b>B</b> 		in assenza di overloading, i parametri passati non devono eccedere i parametri dell&#x27;intestazione del metodo, ma possono anche essere di pi&ugrave;.
</li>
<li><b>C</b> 		in assenza di overloading, i parametri passati non devono eccedere i parametri dell&#x27;intestazione del metodo, ma possono anche essere di meno.
</li>
<li><b>D</b> 		i parametri formali dell&#x27;invocazione vengono copiati nei corrispondenti parametri attuali dell&#x27;intestazione del metodo.
</li>
</ul>
<center><h3><b>Domanda 5</b></h3></center>
Quali delle seguenti affermazioni relative al ciclo while &egrave; errata?

<ul>
<li><b>A</b> Qualunque sia il codice che definisce il ciclo &egrave; sempre possibile scrivere un ciclo do...while() equivalente.
</li>
<li><b>B</b> All&#x27;interno del ciclo &egrave; sempre possibile utilizzare le istruzioni break e continue.
</li>
<li><b>C</b> Al termine del ciclo la condizione di guardia ha sempre valore false
</li>
<li><b>D</b> Le variabili utilizzate nella condizione di guardia del ciclo possono essere modificate nel corpo del ciclo stesso.
</li>
</ul>
<center><h3><b>Domanda 6</b></h3></center>
	<domanda>
		Siano <tt>R1(A1,A2)</tt> e <tt>R2(A1,A3)</tt> due schemi di relazione. Si consideri la seguente query espressa in SQL:
<pre>
SELECT *
FROM R1, R2
WHERE R1.A1=R2.A1
</pre>
Una sola delle seguenti affermazioni &egrave; vera. Quale?

<ul>
<li><b>A</b> 		la query corrisponde ad un&#x27;espressione dell&#x27;algebra relazionale in cui si usa la sola operazione di selezione dell&#x27;algebra relazionale;
</li>
<li><b>B</b> 		la query corrisponde ad un&#x27;espressione dell&#x27;algebra relazionale in cui si usa la sola operazione di join naturale.
</li>
<li><b>C</b> 		la query corrisponde ad un&#x27;espressione dell&#x27;algebra relazionale in cui si usa una operazione di proiezione ed una operazione di selezione;
</li>
<li><b>D</b> 		la query non corrisponde ad alcuna espressione dell&#x27;algebra relazionale;
</li>
</ul>
<center><h3><b>Domanda 7</b></h3></center>
	<domanda>
Si consideri la classe <tt>ProvaSwitch</tt>, riportata di seguito:
<pre>
public class ProvaSwitch {
	public static void conv(int x) {
		switch (x) {
			case 0:
				System.out.print ("Zero");
			case 1:
				System.out.print ("Uno");
				break;
			default:
				System.out.println ("Errore");
		} 
	}
	public static void main (String[] x) {
		for (int i=0; i<=2; i++)
			conv (i);
	}
}
</pre>
Una sola delle seguenti affermazioni &egrave; vera. Quale?

<ul>
<li><b>A</b> 		L'esecuzione del metodo <tt>main</tt> causa la stampa di <tt>ZeroUnoErrore</tt>
</li>
<li><b>B</b> 		L'esecuzione del metodo <tt>main</tt> causa la stampa di <tt>ZeroUno</tt>
</li>
<li><b>C</b> 		L'esecuzione del metodo <tt>main</tt> causa la stampa di <tt>ZeroUnoDue</tt>
</li>
<li><b>D</b> 		L'esecuzione del metodo <tt>main</tt> causa la stampa di <tt>ZeroUnoUnoErrore</tt>
</li>
</ul>
<center><h3><b>Domanda 8</b></h3></center>
	<domanda>
		Il massimo numero di nodi di un albero binario di altezza h &egrave;

<ul>
<li><b>A</b> 		2<sup>h+1</sup>-1
</li>
<li><b>B</b> 		2<sup>h</sup>
</li>
<li><b>C</b> 		2h
</li>
<li><b>D</b> 		&#x23A3;log<sub>2</sub> h&#x23A6;
</li>
</ul>
<center><h3><b>Domanda 9</b></h3></center>
	<domanda>
		Si consideri un&rsquo;architettura di comunicazione protocollare a strati (layered); In un sistema terminale (es. un PC connesso in rete) il flusso informativo di dati attraversa gli strati protocollari:

<ul>
<li><b>A</b> 		senza seguire un particolare ordine gerarchico
</li>
<li><b>B</b> 		sempre in senso gerarchico crescente
</li>
<li><b>C</b> 		sempre in senso gerarchico decrescente 
</li>
<li><b>D</b> 		in senso gerarchico decrescente se il terminale &egrave; di origine
</li>
</ul>
<center><h3><b>Domanda 10</b></h3></center>
	<domanda>
		Le variabili statiche di un processo sono memorizzate nel segmento:

<ul>
<li><b>A</b> 		HEAP
</li>
<li><b>B</b> 		DATA
</li>
<li><b>C</b> 		STACK
</li>
<li><b>D</b> 		CODE
</li>
</ul>
</body></html>
